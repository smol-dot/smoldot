// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

import { Config as SmoldotBindingsConfig, default as smoldotLightBindingsBuilder } from './bindings-smoldot-light.js';
import { Config as WasiConfig, default as wasiBindingsBuilder } from './bindings-wasi.js';

import * as buffer from './buffer.js';
import { SmoldotWasmInstance } from './bindings.js';

export interface Config<A> {
    eventCallback: (event: Event<A>) => void,
    parseMultiaddr: (address: string) => { success: true, address: A } | { success: false, error: string },
    wasmModule: WebAssembly.Module,
    maxLogLevel: number;
    cpuRateLimit: number,
    periodicallyYield: boolean,

    /**
     * Returns the number of milliseconds since an arbitrary epoch.
     */
    performanceNow: () => number,

    /**
     * Fills the given buffer with randomly-generated bytes.
     */
    getRandomValues: (buffer: Uint8Array) => void,
}

type Event<A> =
    { ty: "log", level: number, target: string, message: string } |
    { ty: "json-rpc-responses-non-empty", chainId: number } |
    { ty: "current-task", taskName: string | null } |
    { ty: "wasm-panic", message: string } |
    { ty: "new-connection", connectionId: number, address: A } |
    { ty: "connection-reset", connectionId: number } |
    { ty: "connection-stream-open", connectionId: number } |
    { ty: "connection-stream-reset", connectionId: number, streamId: number } |
    { ty: "stream-send", connectionId: number, streamId?: number, data: Uint8Array } |
    { ty: "stream-send-close", connectionId: number, streamId?: number };

export interface Instance {
    request: (request: string, chainId: number) => number,
    peekJsonRpcResponse: (chainId: number) => string | null,
    addChain: (chainSpec: string, databaseContent: string, potentialRelayChains: number[], disableJsonRpc: boolean) => { success: true, chainId: number } | { success: false, error: string },
    removeChain: (chainId: number) => void,
    startShutdown: () => void,
    connectionOpened: (connectionId: number, info: { type: 'single-stream', handshake: 'multistream-select-noise-yamux', initialWritableBytes: number, writeClosable: boolean } | { type: 'multi-stream', handshake: 'webrtc', localTlsCertificateMultihash: Uint8Array, remoteTlsCertificateMultihash: Uint8Array }) => void,
    connectionReset: (connectionId: number, message: string) => void,
    streamWritableBytes: (connectionId: number, numExtra: number, streamId?: number) => void,
    streamMessage: (connectionId: number, message: Uint8Array, streamId?: number) => void,
    streamOpened: (connectionId: number, streamId: number, direction: 'inbound' | 'outbound', initialWritableBytes: number) => void,
    streamReset: (connectionId: number, streamId: number) => void,
    setPeriodicallyYield: (y: boolean) => void,
}

export async function startInstance<A>(config: Config<A>): Promise<Instance> {
    let killAll: () => void;

    const bufferIndices = new Array;
    // Callback called when `advance_execution_ready` is called by the Rust code, if any.
    const advanceExecutionPromise: { value: null | (() => void) } = { value: null };
    const yieldThresholdMs = { value: config.periodicallyYield ? 5 : 2000 };

    // Used to bind with the smoldot-light bindings. See the `bindings-smoldot-light.js` file.
    const smoldotJsConfig: SmoldotBindingsConfig<A> = {
        bufferIndices,
        onPanic: (message) => {
            killAll();
            config.eventCallback({ ty: "wasm-panic", message });
            throw new Error();
        },
        advanceExecutionReadyCallback: () => {
            if (advanceExecutionPromise.value)
                advanceExecutionPromise.value();
            advanceExecutionPromise.value = null;
        },
        jsonRpcResponsesNonEmptyCallback: (chainId) => {
            config.eventCallback({ ty: "json-rpc-responses-non-empty", chainId });
        },
        logCallback: (level, target, message) => {
            config.eventCallback({ ty: "log", level, message, target });
        },
        newConnection: (connectionId: number, address: A) => {
            config.eventCallback({ ty: "new-connection", connectionId, address });
        },
        connectionReset: (connectionId: number) => {
            config.eventCallback({ ty: "connection-reset", connectionId });
        },
        connectionStreamOpen: (connectionId: number) => {
            config.eventCallback({ ty: "connection-stream-open", connectionId });
        },
        connectionStreamReset: (connectionId: number, streamId: number) => {
            config.eventCallback({ ty: "connection-stream-reset", connectionId, streamId });
        },
        streamSend: (connectionId: number, data: Uint8Array, streamId?: number) => {
            config.eventCallback({ ty: "stream-send", connectionId, streamId, data });
        },
        streamSendClosed: (connectionId: number, streamId?: number) => {
            config.eventCallback({ ty: "stream-send-close", connectionId, streamId });
        },
        ...config
    };

    // Used to bind with the Wasi bindings. See the `bindings-wasi.js` file.
    const wasiConfig: WasiConfig = {
        envVars: [],
        getRandomValues: config.getRandomValues,
        performanceNow: config.performanceNow,
        onProcExit: (retCode) => {
            killAll();
            config.eventCallback({ ty: "wasm-panic", message: `proc_exit called: ${retCode}` });
            throw new Error();
        }
    };

    const { imports: smoldotBindings, killAll: smoldotBindingsKillAll } =
        smoldotLightBindingsBuilder(smoldotJsConfig);

    killAll = smoldotBindingsKillAll;

    // Start the Wasm virtual machine.
    // The Rust code defines a list of imports that must be fulfilled by the environment. The second
    // parameter provides their implementations.
    const result = await WebAssembly.instantiate(config.wasmModule, {
        // The functions with the "smoldot" prefix are specific to smoldot.
        "smoldot": smoldotBindings,
        // As the Rust code is compiled for wasi, some more wasi-specific imports exist.
        "wasi_snapshot_preview1": wasiBindingsBuilder(wasiConfig),
    });

    const instance = result as SmoldotWasmInstance;
    smoldotJsConfig.instance = instance;
    wasiConfig.instance = instance;

    // Smoldot requires an initial call to the `init` function in order to do its internal
    // configuration.
    instance.exports.init(config.maxLogLevel);

    (async () => {
        // In order to avoid calling `setTimeout` too often, we accumulate sleep up until
        // a certain threshold.
        let missingSleep = 0;

        // Extract (to make sure the value doesn't change) and sanitize `cpuRateLimit`.
        let cpuRateLimit = config.cpuRateLimit;
        if (isNaN(cpuRateLimit)) cpuRateLimit = 1.0;
        if (cpuRateLimit > 1.0) cpuRateLimit = 1.0;
        if (cpuRateLimit < 0.0) cpuRateLimit = 0.0;

        let now = config.performanceNow();

        while (true) {
            const whenReadyAgain = new Promise((resolve) => advanceExecutionPromise.value = resolve as () => void);

            const outcome = instance.exports.advance_execution();
            if (outcome === 0) {
                break;
            }

            const afterExec = config.performanceNow();
            const elapsed = afterExec - now;
            now = afterExec;

            // In order to enforce the rate limiting, we stop executing for a certain
            // amount of time.
            // The base equation here is: `(sleep + elapsed) * rateLimit == elapsed`,
            // from which the calculation below is derived.
            const sleep = elapsed * (1.0 / cpuRateLimit - 1.0);
            missingSleep += sleep;

            if (missingSleep > yieldThresholdMs.value) {
                // `setTimeout` has a maximum value, after which it will overflow. ðŸ¤¦
                // See <https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#maximum_delay_value>
                // While adding a cap technically skews the CPU rate limiting algorithm, we don't
                // really care for such extreme values.
                if (missingSleep > 2147483646)  // Doc says `> 2147483647`, but I don't really trust their pedanticism so let's be safe
                    missingSleep = 2147483646;
                await new Promise((resolve) => setTimeout(resolve, missingSleep));
                missingSleep = 0;
            }

            await whenReadyAgain;

            const afterWait = config.performanceNow();
            missingSleep -= (afterWait - now);
            if (missingSleep < 0)
                missingSleep = 0;
            now = afterWait;
        }
    })();

    return {
        request: (request: string, chainId: number) => {
            bufferIndices[0] = new TextEncoder().encode(request);
            return instance.exports.json_rpc_send(0, chainId) >>> 0;
        },

        peekJsonRpcResponse: (chainId: number): string | null => {
            const mem = new Uint8Array(instance.exports.memory.buffer);
            const responseInfo = instance.exports.json_rpc_responses_peek(chainId) >>> 0;
            const ptr = buffer.readUInt32LE(mem, responseInfo) >>> 0;
            const len = buffer.readUInt32LE(mem, responseInfo + 4) >>> 0;

            // `len === 0` means "queue is empty" according to the API.
            // In that situation, queue the resolve/reject.
            if (len !== 0) {
                const message = buffer.utf8BytesToString(mem, ptr, len);
                instance.exports.json_rpc_responses_pop(chainId);
                return message;
            } else {
                return null
            }
        },

        addChain: (chainSpec: string, databaseContent: string, potentialRelayChains: number[], disableJsonRpc: boolean): { success: true, chainId: number } | { success: false, error: string } => {
            // `add_chain` unconditionally allocates a chain id. If an error occurs, however, this chain
            // id will refer to an *erroneous* chain. `chain_is_ok` is used below to determine whether it
            // has succeeeded or not.
            bufferIndices[0] = new TextEncoder().encode(chainSpec)
            bufferIndices[1] = new TextEncoder().encode(databaseContent)
            const potentialRelayChainsEncoded = new Uint8Array(potentialRelayChains.length * 4)
            for (let idx = 0; idx < potentialRelayChains.length; ++idx) {
                buffer.writeUInt32LE(potentialRelayChainsEncoded, idx * 4, potentialRelayChains[idx]!);
            }
            bufferIndices[2] = potentialRelayChainsEncoded
            const chainId = instance.exports.add_chain(0, 1, disableJsonRpc ? 0 : 1, 2);

            delete bufferIndices[0]
            delete bufferIndices[1]
            delete bufferIndices[2]

            if (instance.exports.chain_is_ok(chainId) != 0) {
                return { success: true, chainId };
            } else {
                const errorMsgLen = instance.exports.chain_error_len(chainId) >>> 0;
                const errorMsgPtr = instance.exports.chain_error_ptr(chainId) >>> 0;
                const errorMsg = buffer.utf8BytesToString(new Uint8Array(instance.exports.memory.buffer), errorMsgPtr, errorMsgLen);
                instance.exports.remove_chain(chainId);
                return { success: false, error: errorMsg };
            }
        },

        removeChain: (chainId: number): void => {
            instance.exports.remove_chain(chainId);
        },

        startShutdown: (): void => {
            instance.exports.start_shutdown();
        },

        connectionOpened: (connectionId: number, info: { type: 'single-stream', handshake: 'multistream-select-noise-yamux', initialWritableBytes: number, writeClosable: boolean } | { type: 'multi-stream', handshake: 'webrtc', localTlsCertificateMultihash: Uint8Array, remoteTlsCertificateMultihash: Uint8Array }) => {
            switch (info.type) {
                case 'single-stream': {
                    instance.exports.connection_open_single_stream(connectionId, 0, info.initialWritableBytes, info.writeClosable ? 1 : 0);
                    break
                }
                case 'multi-stream': {
                    const handshakeTy = new Uint8Array(1 + info.localTlsCertificateMultihash.length + info.remoteTlsCertificateMultihash.length);
                    buffer.writeUInt8(handshakeTy, 0, 0);
                    handshakeTy.set(info.localTlsCertificateMultihash, 1)
                    handshakeTy.set(info.remoteTlsCertificateMultihash, 1 + info.localTlsCertificateMultihash.length)
                    bufferIndices[0] = handshakeTy;
                    instance.exports.connection_open_multi_stream(connectionId, 0);
                    delete bufferIndices[0]
                    break
                }
            }
        },

        connectionReset: (connectionId: number, message: string) => {
            bufferIndices[0] = new TextEncoder().encode(message);
            instance.exports.connection_reset(connectionId, 0);
            delete bufferIndices[0]
        },

        streamWritableBytes: (connectionId: number, numExtra: number, streamId?: number) => {
            instance.exports.stream_writable_bytes(
                connectionId,
                streamId || 0,
                numExtra,
            );
        },

        streamMessage: (connectionId: number, message: Uint8Array, streamId?: number) => {
            bufferIndices[0] = message;
            instance.exports.stream_message(connectionId, streamId || 0, 0);
            delete bufferIndices[0]
        },

        streamOpened: (connectionId: number, streamId: number, direction: 'inbound' | 'outbound', initialWritableBytes: number) => {
            instance.exports.connection_stream_opened(
                connectionId,
                streamId,
                direction === 'outbound' ? 1 : 0,
                initialWritableBytes
            );
        },

        streamReset: (connectionId: number, streamId: number) => {
            instance.exports.stream_reset(connectionId, streamId);
        },

        setPeriodicallyYield: (y: boolean) => {
            if (y) {
                yieldThresholdMs.value = 5;
            } else {
                yieldThresholdMs.value = 2000;
            }
        },
    };
}

// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

import { ConnectionConfig, Connection, Config as SmoldotBindingsConfig, default as smoldotLightBindingsBuilder } from './bindings-smoldot-light.js';
import { Config as WasiConfig, default as wasiBindingsBuilder } from './bindings-wasi.js';

import { SmoldotWasmInstance } from './bindings.js';

export { ConnectionConfig, ConnectionError, Connection } from './bindings-smoldot-light.js';

export interface Config {
    /**
     * Closure to call when the Wasm instance panics.
     *
     * This callback will always be invoked from within a binding called the Wasm instance.
     *
     * After this callback has been called, it is forbidden to invoke any function from the Wasm
     * VM.
     *
     * If this callback is called while invoking a function from the Wasm VM, this function will
     * throw a dummy exception.
     */
    onWasmPanic: (message: string) => void,
    logCallback: (level: number, target: string, message: string) => void,
    currentTaskCallback?: (taskName: string | null) => void,
    wasmModule: { module: WebAssembly.Module, memory: WebAssembly.Memory },
    cpuRateLimit: number,
    executeNonNetworkingTasks: { value: boolean },
}

/**
 * Contains functions that the client will use when it needs to leverage the platform.
 */
export interface PlatformBindings {
    /**
     * Returns the number of milliseconds since an arbitrary epoch.
     */
    performanceNow: () => number,

    /**
     * Fills the given buffer with randomly-generated bytes.
     */
    getRandomValues: (buffer: Uint8Array) => void,

    /**
     * Tries to open a new connection using the given configuration.
     *
     * @see Connection
     * @throws {@link ConnectionError} If the multiaddress couldn't be parsed or contains an invalid protocol.
     */
    connect: ((config: ConnectionConfig) => Connection) | null;
}

export async function startInstance(config: Config, platformBindings: PlatformBindings): Promise<[SmoldotWasmInstance, Array<Uint8Array>, Promise<void>]> {
    let killAll: () => void;

    const bufferIndices = new Array;

    // Used to bind with the smoldot-light bindings. See the `bindings-smoldot-light.js` file.
    const smoldotJsConfig: SmoldotBindingsConfig = {
        memory: config.wasmModule.memory,
        bufferIndices,
        connect: platformBindings.connect,
        onPanic: (message) => {
            killAll();
            config.onWasmPanic(message);
            throw new Error();
        },
        ...config
    };

    // Used to bind with the Wasi bindings. See the `bindings-wasi.js` file.
    const wasiConfig: WasiConfig = {
        memory: config.wasmModule.memory,
        envVars: [],
        getRandomValues: platformBindings.getRandomValues,
        performanceNow: platformBindings.performanceNow,
        onProcExit: (retCode) => {
            killAll();
            config.onWasmPanic(`proc_exit called: ${retCode}`)
            throw new Error();
        }
    };

    const { imports: smoldotBindings, killAll: smoldotBindingsKillAll } =
        smoldotLightBindingsBuilder(smoldotJsConfig);

    killAll = smoldotBindingsKillAll;

    // Start the Wasm virtual machine.
    // The Rust code defines a list of imports that must be fulfilled by the environment. The
    // second parameter provides their implementations.
    const result = await WebAssembly.instantiate(config.wasmModule.module, {
        // The functions with the "smoldot" prefix are specific to smoldot.
        "smoldot": smoldotBindings,
        // As the Rust code is compiled for wasi, some more wasi-specific imports exist.
        "wasi_snapshot_preview1": wasiBindingsBuilder(wasiConfig),
        // The memory is imported by the Wasm rather than exported.
        "env": { "memory": config.wasmModule.memory, }
    });

    const instance = result as SmoldotWasmInstance;
    smoldotJsConfig.instance = instance;

    // TODO: this execution might start before `init` is called; it's actually okay to do so in practice, but the documentation says it's forbidden
    const executor = (async () => {
        // In order to avoid calling `setTimeout` too often, we accumulate sleep up until
        // a certain threshold.
        let missingSleep = 0;

        // Extract (to make sure the value doesn't change) and sanitize `cpuRateLimit`.
        let cpuRateLimit = config.cpuRateLimit;
        if (isNaN(cpuRateLimit)) cpuRateLimit = 1.0;
        if (cpuRateLimit > 1.0) cpuRateLimit = 1.0;
        if (cpuRateLimit < 0.0) cpuRateLimit = 0.0;

        const executeNonNetworkingTasks = config.executeNonNetworkingTasks;

        while (true) {
            const before = platformBindings.performanceNow();

            // TODO: proper value for execNonNetworking
            const ptr = instance.exports.advance_execution(
                platformBindings.connect !== null ? 1 : 0,
                executeNonNetworkingTasks.value ? 1 : 0
            ) >>> 0;
            if (ptr === 0)
                break;

            const after = platformBindings.performanceNow();
            const elapsed = after - before;

            // In order to enforce the rate limiting, we stop executing for a certain
            // amount of time.
            // The base equation here is: `(sleep + elapsed) * rateLimit == elapsed`,
            // from which the calculation below is derived.
            const sleep = elapsed * (1.0 / cpuRateLimit - 1.0);
            missingSleep += sleep;

            if (missingSleep > 5) { // TODO: || (state.initialized && state.periodicallyYield))
                await new Promise((resolve) => setTimeout(resolve, missingSleep));
                missingSleep = 0;
            }

            // TODO: `waitAsync` is missing from TS bindings
            // TODO: `waitAsync` isn't supported by Firefox: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/waitAsync
            interface AtomicsExtra {
                waitAsync(typedArray: Int32Array, index: number, value: number, timeout?: number): { async: true, value: Promise<"ok" | "timed-out"> } | { async: false, value: "not-equal" | "timed-out" };
            }
            const waitReturn = (Atomics as unknown as AtomicsExtra).waitAsync(new Int32Array(config.wasmModule.memory.buffer), ptr / 4, 0);
            if (waitReturn.async) {
                await waitReturn.value
            }
        }
    })();

    return [instance, bufferIndices, executor];
}

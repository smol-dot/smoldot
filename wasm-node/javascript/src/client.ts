// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

import { start as startInstance } from './instance/instance.js';
import { Client, ClientOptions, AlreadyDestroyedError, AddChainError, AddChainOptions, Chain, JsonRpcDisabledError, MalformedJsonRpcError } from './public-types.js';

/**
 * Contains functions that the client will use when it needs to leverage the platform.
 */
export interface PlatformBindings<A> {
    /**
     * Tries to open a new connection using the given configuration.
     *
     * @see Connection
     * @throws {@link ConnectionError} If the multiaddress couldn't be parsed or contains an invalid protocol.
     */
    connect(config: ConnectionConfig<A>): Connection;

    /**
     * Returns the number of milliseconds since an arbitrary epoch.
     */
    performanceNow: () => number,

    /**
     * Fills the given buffer with randomly-generated bytes.
     */
    getRandomValues: (buffer: Uint8Array) => void,

    parseMultiaddr(address: string): { success: true, address: A } | { success: false, error: string };
}

/**
 * Connection to a remote node.
 *
 * At any time, a connection can be in one of the three following states:
 *
 * - `Opening` (initial state)
 * - `Open`
 * - `Reset`
 *
 * When in the `Opening` or `Open` state, the connection can transition to the `Reset` state
 * if the remote closes the connection or refuses the connection altogether. When that
 * happens, `config.onReset` is called. Once in the `Reset` state, the connection cannot
 * transition back to another state.
 *
 * Initially in the `Opening` state, the connection can transition to the `Open` state if the
 * remote accepts the connection. When that happens, `config.onOpen` is called.
 *
 * When in the `Open` state, the connection can receive messages. When a message is received,
 * `config.onMessage` is called.
 *
 * @see connect
 */
export interface Connection {
    /**
     * Transitions the connection or one of its substreams to the `Reset` state.
     *
     * If the connection is of type "single-stream", the whole connection must be shut down.
     * If the connection is of type "multi-stream", a `streamId` can be provided, in which case
     * only the given substream is shut down.
     *
     * The `config.onReset` or `config.onStreamReset` callbacks are **not** called.
     *
     * The transition is performed in the background.
     * If the whole connection is to be shut down, none of the callbacks passed to the `Config`
     * must be called again. If only a substream is shut down, the `onStreamReset` and `onMessage`
     * callbacks must not be called again with that substream.
     */
    reset(streamId?: number): void;

    /**
     * Queues data to be sent on the given connection.
     *
     * The connection and stream must currently be in the `Open` state.
     *
     * The number of bytes must never exceed the number of "writable bytes" of the stream.
     * `onWritableBytes` can be used in order to notify that more writable bytes are available.
     *
     * The `streamId` must be provided if and only if the connection is of type "multi-stream".
     * It indicates which substream to send the data on.
     *
     * Must not be called after `closeSend` has been called.
     */
    send(data: Uint8Array, streamId?: number): void;

    /**
     * Closes the writing side of the given stream of the given connection.
     *
     * Never called for connection types where this isn't possible to implement (i.e. WebSocket
     * and WebRTC at the moment).
     *
     * The connection and stream must currently be in the `Open` state.
     *
     * Implicitly sets the "writable bytes" of the stream to zero.
     *
     * The `streamId` must be provided if and only if the connection is of type "multi-stream".
     * It indicates which substream to send the data on.
     *
     * Must only be called once per stream.
     */
    closeSend(streamId?: number): void;

    /**
     * Start opening an additional outbound substream on the given connection.
     *
     * The state of the connection must be `Open`. This function must only be called for
     * connections of type "multi-stream".
     *
     * The `onStreamOpened` callback must later be called with an outbound direction.
     * 
     * Note that no mechanism exists in this API to handle the situation where a substream fails
     * to open, as this is not supposed to happen. If you need to handle such a situation, either
     * try again opening a substream again or reset the entire connection.
     */
    openOutSubstream(): void;
}

/**
 * Configuration for a connection.
 *
 * @see connect
 */
export interface ConnectionConfig<C> {
    /**
     * Parsed multiaddress, as returned by the `parseMultiaddr` function.
     */
    address: C,

    /**
     * Callback called when the connection transitions from the `Opening` to the `Open` state.
     *
     * Must only be called once per connection.
     */
    onOpen: (info:
        {
            type: 'single-stream', handshake: 'multistream-select-noise-yamux',
            initialWritableBytes: number, writeClosable: boolean
        } |
        {
            type: 'multi-stream', handshake: 'webrtc',
            localTlsCertificateMultihash: Uint8Array,
            remoteTlsCertificateMultihash: Uint8Array,
        }
    ) => void;

    /**
     * Callback called when the connection transitions to the `Reset` state.
     *
     * It it **not** called if `Connection.reset` is manually called by the API user.
     */
    onConnectionReset: (message: string) => void;

    /**
     * Callback called when a new substream has been opened.
     *
     * This function must only be called for connections of type "multi-stream".
     */
    onStreamOpened: (streamId: number, direction: 'inbound' | 'outbound', initialWritableBytes: number) => void;

    /**
     * Callback called when a stream transitions to the `Reset` state.
     *
     * It it **not** called if `Connection.resetStream` is manually called by the API user.
     *
     * This function must only be called for connections of type "multi-stream".
     */
    onStreamReset: (streamId: number) => void;

    /**
     * Callback called when some data sent using {@link Connection.send} has effectively been
     * written on the stream, meaning that some buffer space is now free.
     *
     * Can only happen while the connection is in the `Open` state.
     *
     * This callback must not be called after `closeSend` has been called.
     *
     * The `streamId` parameter must be provided if and only if the connection is of type
     * "multi-stream".
     *
     * Only a number of bytes equal to the size of the data provided to {@link Connection.send}
     * must be reported. In other words, the `initialWritableBytes` must never be exceeded.
     */
    onWritableBytes: (numExtra: number, streamId?: number) => void;

    /**
     * Callback called when a message sent by the remote has been received.
     *
     * Can only happen while the connection is in the `Open` state.
     *
     * The `streamId` parameter must be provided if and only if the connection is of type
     * "multi-stream".
     */
    onMessage: (message: Uint8Array, streamId?: number) => void;
}

// This function is similar to the `start` function found in `index.ts`, except with an extra
// parameter containing the platform-specific bindings.
// Contrary to the one within `index.js`, this function is not supposed to be directly used.
export function start<A>(options: ClientOptions, wasmModule: Promise<WebAssembly.Module>, platformBindings: PlatformBindings<A>): Client {
    const logCallback = options.logCallback || ((level, target, message) => {
        // The first parameter of the methods of `console` has some printf-like substitution
        // capabilities. We don't really need to use this, but not using it means that the logs might
        // not get printed correctly if they contain `%`.
        if (level <= 1) {
            console.error("[%s] %s", target, message);
        } else if (level == 2) {
            console.warn("[%s] %s", target, message);
        } else if (level == 3) {
            console.info("[%s] %s", target, message);
        } else if (level == 4) {
            console.debug("[%s] %s", target, message);
        } else {
            console.trace("[%s] %s", target, message);
        }
    });

    // Extract (to make sure the value doesn't change) and sanitize `cpuRateLimit`.
    let cpuRateLimit = options.cpuRateLimit || 1.0;
    if (isNaN(cpuRateLimit)) cpuRateLimit = 1.0;
    if (cpuRateLimit > 1.0) cpuRateLimit = 1.0;
    if (cpuRateLimit < 0.0) cpuRateLimit = 0.0;

    // This object holds the state of everything.
    const state: {
        // For each chain object returned by `addChain`, the associated internal chain id.
        // Immediately cleared when `remove()` is called on a chain.
        chainIds: WeakMap<Chain, number>,
        // If `Client.terminate()Ì€  is called, this error is set to a value.
        // All the functions of the public API check if this contains a value.
        alreadyDestroyedError: null | AlreadyDestroyedError,
    } = {
        chainIds: new WeakMap(),
        alreadyDestroyedError: null,
    };

    const instance = startInstance({
        wasmModule,
        // Maximum level of log entries sent by the client.
        // 0 = Logging disabled, 1 = Error, 2 = Warn, 3 = Info, 4 = Debug, 5 = Trace
        maxLogLevel: options.maxLogLevel || 3,
        logCallback,
        cpuRateLimit,
    }, platformBindings);

    return {
        addChain: async (options: AddChainOptions): Promise<Chain> => {
            if (state.alreadyDestroyedError)
                throw state.alreadyDestroyedError;

            // Passing a JSON object for the chain spec is an easy mistake, so we provide a more
            // readable error.
            if (!(typeof options.chainSpec === 'string'))
                throw new Error("Chain specification must be a string");

            let potentialRelayChainsIds = [];
            if (!!options.potentialRelayChains) {
                for (const chain of options.potentialRelayChains) {
                    // The content of `options.potentialRelayChains` are supposed to be chains earlier
                    // returned by `addChain`.
                    const id = state.chainIds.get(chain);
                    if (id === undefined) // It is possible for `id` to be missing if it has earlier been removed.
                        continue;
                    potentialRelayChainsIds.push(id);
                }
            }

            const outcome = await instance.addChain(options.chainSpec, typeof options.databaseContent === 'string' ? options.databaseContent : "", potentialRelayChainsIds, !!options.disableJsonRpc);

            if (!outcome.success)
                throw new AddChainError(outcome.error);

            const chainId = outcome.chainId;
            const wasDestroyed = { destroyed: false };

            // `expected` was pushed by the `addChain` method.
            // Resolve the promise that `addChain` returned to the user.
            const newChain: Chain = {
                sendJsonRpc: (request) => {
                    if (state.alreadyDestroyedError)
                        throw state.alreadyDestroyedError;
                    if (wasDestroyed.destroyed)
                        throw new AlreadyDestroyedError();
                    if (options.disableJsonRpc)
                        throw new JsonRpcDisabledError();
                    if (request.length >= 64 * 1024 * 1024) {
                        throw new MalformedJsonRpcError();
                    };
                    instance.request(request, chainId);
                },
                nextJsonRpcResponse: () => {
                    if (state.alreadyDestroyedError)
                        return Promise.reject(state.alreadyDestroyedError);
                    if (wasDestroyed.destroyed)
                        return Promise.reject(new AlreadyDestroyedError());
                    if (options.disableJsonRpc)
                        return Promise.reject(new JsonRpcDisabledError());
                    return instance.nextJsonRpcResponse(chainId);
                },
                remove: () => {
                    if (state.alreadyDestroyedError)
                        throw state.alreadyDestroyedError;
                    if (wasDestroyed.destroyed)
                        throw new AlreadyDestroyedError();
                    wasDestroyed.destroyed = true;
                    console.assert(state.chainIds.has(newChain));
                    state.chainIds.delete(newChain);
                    instance.removeChain(chainId);
                },
            };

            state.chainIds.set(newChain, chainId);
            return newChain;
        },
        terminate: async () => {
            if (state.alreadyDestroyedError)
                throw state.alreadyDestroyedError
            state.alreadyDestroyedError = new AlreadyDestroyedError();
            instance.startShutdown()
        }
    }
}

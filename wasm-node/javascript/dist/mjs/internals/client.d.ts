import { Client, ClientOptions, SmoldotBytecode } from '../public-types.js';
import * as instance from './local-instance.js';
/**
 * Contains functions that the client will use when it needs to leverage the platform.
 */
export interface PlatformBindings {
    /**
     * Tries to open a new connection using the given configuration.
     *
     * In case of a multistream connection, `onMultistreamHandshakeInfo` should be called as soon
     * as possible.
     *
     * @see Connection
     */
    connect(config: ConnectionConfig): Connection;
    /**
     * Returns the number of milliseconds since an arbitrary epoch.
     */
    performanceNow: () => number;
    /**
     * Fills the given buffer with randomly-generated bytes.
     */
    getRandomValues: (buffer: Uint8Array) => void;
}
/**
 * Connection to a remote node.
 *
 * At any time, a connection can be in one of the following states:
 *
 * - `Open` (initial state)
 * - `Reset`
 *
 * When in the `Open` state, the connection can transition to the `Reset` state if the remote
 * closes the connection or refuses the connection altogether. When that happens, `config.onReset`
 * is called. Once in the `Reset` state, the connection cannot transition back to `Open`.
 *
 * When in the `Open` state, the connection can receive messages. When a message is received,
 * `config.onMessage` is called.
 *
 * @see connect
 */
export interface Connection {
    /**
     * Transitions the connection or one of its substreams to the `Reset` state.
     *
     * If the connection is of type "single-stream", the whole connection must be shut down.
     * If the connection is of type "multi-stream", a `streamId` can be provided, in which case
     * only the given substream is shut down.
     *
     * The `config.onReset` or `config.onStreamReset` callbacks are **not** called.
     *
     * The transition is performed in the background.
     * If the whole connection is to be shut down, none of the callbacks passed to the `Config`
     * must be called again. If only a substream is shut down, the `onStreamReset` and `onMessage`
     * callbacks must not be called again with that substream.
     */
    reset(streamId?: number): void;
    /**
     * Queues data to be sent on the given connection.
     *
     * The connection and stream must currently be in the `Open` state.
     *
     * The number of bytes must never exceed the number of "writable bytes" of the stream.
     * `onWritableBytes` can be used in order to notify that more writable bytes are available.
     *
     * The `streamId` must be provided if and only if the connection is of type "multi-stream".
     * It indicates which substream to send the data on.
     *
     * Must not be called after `closeSend` has been called.
     */
    send(data: Array<Uint8Array>, streamId?: number): void;
    /**
     * Closes the writing side of the given stream of the given connection.
     *
     * Never called for connection types where this isn't possible to implement (i.e. WebSocket
     * and WebRTC at the moment).
     *
     * The connection and stream must currently be in the `Open` state.
     *
     * Implicitly sets the "writable bytes" of the stream to zero.
     *
     * The `streamId` must be provided if and only if the connection is of type "multi-stream".
     * It indicates which substream to send the data on.
     *
     * Must only be called once per stream.
     */
    closeSend(streamId?: number): void;
    /**
     * Start opening an additional outbound substream on the given connection.
     *
     * The state of the connection must be `Open`. This function must only be called for
     * connections of type "multi-stream".
     *
     * The `onStreamOpened` callback must later be called with an outbound direction.
     *
     * Note that no mechanism exists in this API to handle the situation where a substream fails
     * to open, as this is not supposed to happen. If you need to handle such a situation, either
     * try again opening a substream again or reset the entire connection.
     */
    openOutSubstream(): void;
}
/**
 * Configuration for a connection.
 *
 * @see connect
 */
export interface ConnectionConfig {
    /**
     * Parsed multiaddress, as returned by the `parseMultiaddr` function.
     */
    address: instance.ParsedMultiaddr;
    /**
     * Callback called when a multistream connection knows information about its handshake. Should
     * be called as soon as possible.
     *
     * Can only happen while the connection is in the `Open` state.
     *
     * Must only be called once per connection.
     */
    onMultistreamHandshakeInfo: (info: {
        handshake: 'webrtc';
        localTlsCertificateSha256: Uint8Array;
    }) => void;
    /**
     * Callback called when the connection transitions to the `Reset` state.
     *
     * It it **not** called if `Connection.reset` is manually called by the API user.
     */
    onConnectionReset: (message: string) => void;
    /**
     * Callback called when a new substream has been opened.
     *
     * This function must only be called for connections of type "multi-stream".
     */
    onStreamOpened: (streamId: number, direction: 'inbound' | 'outbound') => void;
    /**
     * Callback called when a stream transitions to the `Reset` state.
     *
     * It it **not** called if `Connection.resetStream` is manually called by the API user.
     *
     * This function must only be called for connections of type "multi-stream".
     */
    onStreamReset: (streamId: number, message: string) => void;
    /**
     * Callback called when some data sent using {@link Connection.send} has effectively been
     * written on the stream, meaning that some buffer space is now free.
     *
     * Can only happen while the connection is in the `Open` state.
     * This callback must not be called after `closeSend` has been called.
     *
     * The total of writable bytes must not go beyond reasonable values (e.g. a few megabytes). It
     * is not legal to provide a dummy implementation that simply passes an exceedingly large
     * value.
     *
     * The `streamId` parameter must be provided if and only if the connection is of type
     * "multi-stream".
     */
    onWritableBytes: (numExtra: number, streamId?: number) => void;
    /**
     * Callback called when a message sent by the remote has been received.
     *
     * Can only happen while the connection is in the `Open` state.
     *
     * The `streamId` parameter must be provided if and only if the connection is of type
     * "multi-stream".
     */
    onMessage: (message: Uint8Array, streamId?: number) => void;
}
export declare function start(options: ClientOptions, wasmModule: SmoldotBytecode | Promise<SmoldotBytecode>, platformBindings: PlatformBindings): Client;

<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Radix-16 Merkle-Patricia trie."><title>smoldot::trie - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="smoldot" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0 (29483883e 2025-08-04)" data-channel="1.89.0" data-search-js="search-92309212.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-4e99c027.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../smoldot/index.html">smoldot</a><span class="version">0.19.4</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module trie</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#overview" title="Overview">Overview</a><ul><li><a href="#efficient-updates" title="Efficient updates">Efficient updates</a></li><li><a href="#proof-of-storage-entry" title="Proof of storage entry">Proof of storage entry</a></li></ul></li><li><a href="#details" title="Details">Details</a><ul><li><a href="#trie-entry-version" title="Trie entry version">Trie entry version</a></li></ul></li></ul><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate smoldot</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">smoldot</a></div><h1>Module <span>trie</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/smoldot/trie.rs.html#18-425">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Radix-16 Merkle-Patricia trie.</p>
<p>This Substrate/Polkadot-specific radix-16 Merkle-Patricia trie is a data structure that
associates keys with values, and that allows efficient verification of the integrity of the
data.</p>
<h2 id="overview"><a class="doc-anchor" href="#overview">§</a>Overview</h2>
<p>The key-value storage that the blockchain maintains is represented by
<a href="https://en.wikipedia.org/wiki/Tree_data_structure">a tree</a>, where each key-value pair in the
storage corresponds to a node in that tree.</p>
<p>Each node in this tree has what is called a Merkle value associated to it. This Merkle value
consists, in its essence, in the combination of the storage value associated to that node and
the Merkle values of all of the node’s children. If the resulting Merkle value would be too
long, it is first hashed.</p>
<p>Since the Merkle values of a node’s children depend, in turn, of the Merkle value of their
own children, we can say that the Merkle value of a node depends on all of the node’s
descendants.</p>
<p>Consequently, the Merkle value of the root node of the tree depends on the storage values of
all the nodes in the tree.</p>
<p>See also <a href="https://en.wikipedia.org/wiki/Merkle_tree">the Wikipedia page for Merkle tree for a different
explanation</a>.</p>
<h3 id="efficient-updates"><a class="doc-anchor" href="#efficient-updates">§</a>Efficient updates</h3>
<p>When a storage value gets modified, the Merkle value of the root node of the tree also gets
modified. Thanks to the tree layout, we don’t need to recalculate the Merkle value of the
entire tree, but only of the ancestors of the node which has been modified.</p>
<p>If the storage consists of N entries, recalculating the Merkle value of the trie root requires
on average only <code>log16(N)</code> operations.</p>
<h3 id="proof-of-storage-entry"><a class="doc-anchor" href="#proof-of-storage-entry">§</a>Proof of storage entry</h3>
<p>In the situation where we want to know the storage value associated to a node, but we only
know the Merkle value of the root of the trie, it is possible to ask a third-party for the
unhashed Merkle values of the desired node and all its ancestors. This is called a Merkle
proof.</p>
<p>After having verified that the third-party has provided correct values, and that they match
the expected root node Merkle value known locally, we can extract the storage value from the
Merkle value of the desired node.</p>
<h2 id="details"><a class="doc-anchor" href="#details">§</a>Details</h2>
<p>This data structure is a tree composed of nodes, each node being identified by a key. A key
consists in a sequence of 4-bits values called <em>nibbles</em>. Example key: <code>[3, 12, 7, 0]</code>.</p>
<p>Some of these nodes contain a value.</p>
<p>A node A is an <em>ancestor</em> of another node B if the key of A is a prefix of the key of B. For
example, the node whose key is <code>[3, 12]</code> is an ancestor of the node whose key is
<code>[3, 12, 8, 9]</code>. B is a <em>descendant</em> of A.</p>
<p>Nodes exist only either if they contain a value, or if their key is the longest shared prefix
of two or more nodes that contain a value. For example, if nodes <code>[7, 2, 9, 11]</code> and
<code>[7, 2, 14, 8]</code> contain a value, then node <code>[7, 2]</code> also exist, because it is the longest
prefix shared between the two.</p>
<p>The <em>Merkle value</em> of a node is composed, amongst other things, of its associated value and of
the Merkle value of its descendants. As such, modifying a node modifies the Merkle value of
all its ancestors. Note, however, that modifying a node modifies the Merkle value of <em>only</em>
its ancestors. As such, the time spent calculating the Merkle value of the root node of a trie
mostly depends on the number of modifications that are performed on it, and only a bit on the
size of the trie.</p>
<h3 id="trie-entry-version"><a class="doc-anchor" href="#trie-entry-version">§</a>Trie entry version</h3>
<p>In the Substrate/Polkadot trie, each trie node that contains a value also has a version
associated to it.</p>
<p>This version changes the way the hash of the node is calculated and how the Merkle proof is
generated. Version 1 leads to more succinct Merkle proofs, which is important when these proofs
are sent over the Internet.</p>
<p>Note that most of the time all the entries of the trie have the same version. However, it is
possible for the trie to be in a hybrid state where some entries have a certain version and
other entries a different version. For this reason, most of the trie-related APIs require you
to provide a trie entry version alongside with the value.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="branch_search/index.html" title="mod smoldot::trie::branch_search">branch_<wbr>search</a></dt><dd>Allows searching for the closest branch node in a trie when only the storage trie nodes are
known.</dd><dt><a class="mod" href="calculate_root/index.html" title="mod smoldot::trie::calculate_root">calculate_<wbr>root</a></dt><dd>Freestanding function that calculates the root of a radix-16 Merkle-Patricia trie.</dd><dt><a class="mod" href="minimize_proof/index.html" title="mod smoldot::trie::minimize_proof">minimize_<wbr>proof</a></dt><dt><a class="mod" href="prefix_proof/index.html" title="mod smoldot::trie::prefix_proof">prefix_<wbr>proof</a></dt><dd>Scanning, through trie proofs, the list of all keys that share a certain prefix.</dd><dt><a class="mod" href="proof_decode/index.html" title="mod smoldot::trie::proof_decode">proof_<wbr>decode</a></dt><dd>Decodes and verifies a trie proof.</dd><dt><a class="mod" href="proof_encode/index.html" title="mod smoldot::trie::proof_encode">proof_<wbr>encode</a></dt><dt><a class="mod" href="trie_node/index.html" title="mod smoldot::trie::trie_node">trie_<wbr>node</a></dt><dt><a class="mod" href="trie_structure/index.html" title="mod smoldot::trie::trie_structure">trie_<wbr>structure</a></dt><dd>Manages the structure of a trie. Allows inserting and removing nodes, but does not store any
value. Only the structure is stored.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.BytesToNibbles.html" title="struct smoldot::trie::BytesToNibbles">Bytes<wbr>ToNibbles</a></dt><dd>Turns an iterator of bytes into an iterator of nibbles corresponding to these bytes.</dd><dt><a class="struct" href="struct.Nibble.html" title="struct smoldot::trie::Nibble">Nibble</a></dt><dd>A single nibble with four bits.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.HashFunction.html" title="enum smoldot::trie::HashFunction">Hash<wbr>Function</a></dt><dd>Hash algorithm used during trie calculations.</dd><dt><a class="enum" href="enum.NibbleFromU8Error.html" title="enum smoldot::trie::NibbleFromU8Error">Nibble<wbr>From<wbr>U8Error</a></dt><dd>Error when building a <a href="struct.Nibble.html" title="struct smoldot::trie::Nibble"><code>Nibble</code></a> from a <code>u8</code>.</dd><dt><a class="enum" href="enum.TrieEntryVersion.html" title="enum smoldot::trie::TrieEntryVersion">Trie<wbr>Entry<wbr>Version</a></dt><dd>The format of the nodes of trie has two different versions.</dd></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.EMPTY_BLAKE2_TRIE_MERKLE_VALUE.html" title="constant smoldot::trie::EMPTY_BLAKE2_TRIE_MERKLE_VALUE">EMPTY_<wbr>BLAK<wbr>E2_<wbr>TRIE_<wbr>MERKLE_<wbr>VALUE</a></dt><dd>Merkle value of the root node of an empty trie using <a href="enum.HashFunction.html#variant.Blake2" title="variant smoldot::trie::HashFunction::Blake2"><code>HashFunction::Blake2</code></a>.</dd><dt><a class="constant" href="constant.EMPTY_KECCAK256_TRIE_MERKLE_VALUE.html" title="constant smoldot::trie::EMPTY_KECCAK256_TRIE_MERKLE_VALUE">EMPTY_<wbr>KECCA<wbr>K256_<wbr>TRIE_<wbr>MERKLE_<wbr>VALUE</a></dt><dd>Merkle value of the root node of an empty trie using <a href="enum.HashFunction.html#variant.Keccak256" title="variant smoldot::trie::HashFunction::Keccak256"><code>HashFunction::Keccak256</code></a>.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.all_nibbles.html" title="fn smoldot::trie::all_nibbles">all_<wbr>nibbles</a></dt><dd>Returns an iterator of all possible nibble values, in ascending order.</dd><dt><a class="fn" href="fn.bytes_to_nibbles.html" title="fn smoldot::trie::bytes_to_nibbles">bytes_<wbr>to_<wbr>nibbles</a></dt><dd>Turns an iterator of bytes into an iterator of nibbles corresponding to these bytes.</dd><dt><a class="fn" href="fn.nibbles_to_bytes_prefix_extend.html" title="fn smoldot::trie::nibbles_to_bytes_prefix_extend">nibbles_<wbr>to_<wbr>bytes_<wbr>prefix_<wbr>extend</a></dt><dd>Turns an iterator of nibbles into an iterator of bytes.</dd><dt><a class="fn" href="fn.nibbles_to_bytes_suffix_extend.html" title="fn smoldot::trie::nibbles_to_bytes_suffix_extend">nibbles_<wbr>to_<wbr>bytes_<wbr>suffix_<wbr>extend</a></dt><dd>Turns an iterator of nibbles into an iterator of bytes.</dd><dt><a class="fn" href="fn.nibbles_to_bytes_truncate.html" title="fn smoldot::trie::nibbles_to_bytes_truncate">nibbles_<wbr>to_<wbr>bytes_<wbr>truncate</a></dt><dd>Turns an iterator of nibbles into an iterator of bytes.</dd><dt><a class="fn" href="fn.ordered_root.html" title="fn smoldot::trie::ordered_root">ordered_<wbr>root</a></dt><dd>Returns the Merkle value of a trie containing the entries passed as parameter, where the keys
are the SCALE-codec-encoded indices of these entries.</dd><dt><a class="fn" href="fn.trie_root.html" title="fn smoldot::trie::trie_root">trie_<wbr>root</a></dt><dd>Returns the Merkle value of a trie containing the entries passed as parameter. The entries
passed as parameter are <code>(key, value)</code>.</dd></dl></section></div></main></body></html>
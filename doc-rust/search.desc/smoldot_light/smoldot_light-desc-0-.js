searchState.loadedDescShard("smoldot_light", 0, "Smoldot light client library.\nSee <code>Client::add_chain</code>.\nSee <code>AddChainConfig::json_rpc</code>.\nError potentially returned by <code>Client::add_chain</code>.\nReturns by <code>Client::add_chain</code> on success.\nChain registered in a <code>Client</code>.\nThe chain specification must contain either the storage of …\nFailed to decode the specification of the chain.\nHolds a list of chains, connections, and JSON-RPC services.\nNo JSON-RPC endpoint is available for this chain.  This …\nThe JSON-RPC endpoint is enabled. Normal operations.\nError potentially returned when queuing a JSON-RPC request.\nCheckpoint provided in the chain specification is invalid.\nFailed to build the information about the chain from the …\nStream of JSON-RPC responses or notifications.\nThe list of potential relay chains contains more than one …\nThe list of potential relay chains doesn’t contain any …\nThe JSON-RPC service cannot process this request, as too …\nAdds a new chain to the list of chains smoldot tries to …\nNewly-allocated identifier for the chain.\nOpaque data containing the database content that was …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConfiguration for the JSON-RPC endpoint.\nEnqueues a JSON-RPC request towards the given chain.\nStream of JSON-RPC responses or notifications.\nHelper macro for using the …\nBackground network service.\nInitializes the smoldot client.\nReturns the next response or notification, or <code>None</code> if the …\nIf <code>AddChainConfig</code> defines a parachain, contains the list …\nRemoves the chain from smoldot. This instantaneously and …\nJSON text containing the specification of the chain (the …\nOpaque user data that the <code>Client</code> will hold for this chain. …\nMaximum number of JSON-RPC requests that can be added to a …\nMaximum number of active subscriptions that can be started …\nRequest that was being queued.\nAuthorities author blocks and participate in the consensus.\nSeverity of a ban. See …\nError returned by <code>NetworkServiceChain::blocks_request</code>.\nDescription of a call proof request that can be sent to a …\nError returned by <code>NetworkServiceChain::call_proof_request</code>.\nIdentifier of a chain added through <code>ChainNetwork::add_chain</code>…\nConfiguration for a <code>NetworkService</code>.\nSee <code>NetworkService::add_chain</code>.\nUndecoded but valid Merkle proof.\nEvent that can happen on the network service.\nFull nodes store the state of the chain. They are part of …\nReceived a GrandPa commit message from the network.\nLight nodes are the lowest priority nodes.\nNo established connection with the target.\nNo established connection with the target.\nNo established connection with the target.\nNo established connection with the target.\nThere is no valid substream to the given peer on which the …\nIdentifier of a node of the network.\nQueue of notifications with that peer is full.\nError potentially returned when queueing a notification.\nError during the request.\nError during the request.\nError during the request.\nError during the request.\nStorage proof request is too large and can’t be sent.\nCall proof request is too large and can’t be sent.\nRole a node reports playing on the network.\nError returned by …\nError returned by …\nAdds a chain to the list of chains that the network …\nAnnounces transaction to the peers we are connected to.\nReturns a raw bytes representation of this <code>PeerId</code>.\nStarts asynchronously disconnecting the given peer. A …\nNumber and hash of the current best block. Can later be …\nHash of the block to request the storage of.\nNumber of bytes of the block number in the networking …\nSends a blocks request to the given peer.\nSends a call proof request to the given peer.\nCapacity to allocate for the list of chains.\nDelay after which the service can open a new connection. …\nMaximum number of connections that the service can open …\nReturns the SCALE-encoded Merkle proof.\nMarks the given peers as belonging to the given chain, and …\nReturns a list of nodes (their <code>PeerId</code> and multiaddresses) …\nOptional identifier to insert into the networking protocol …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nChecks whether <code>data</code> is a valid <code>PeerId</code>.\nBuilds the <code>PeerId</code> corresponding to a public key.\nHash of the genesis block of the chain. Sent to other …\nMust be <code>Some</code> if and only if the chain uses the GrandPa …\nSends a grandpa warp sync request to the given peer.\nValue sent back for the agent version when receiving an …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a raw bytes representation of this <code>PeerId</code>.\nReturns <code>true</code> if this is caused by networking issues, as …\nName of the chain, for logging purposes.\nName of the runtime function to call.\nInitializes the network service with the given …\nNumber of “out slots” of this chain. We establish …\nIterator to buffers of bytes to be concatenated then …\nReturns an iterator to the list of <code>PeerId</code>s that we have an …\nAccess to the platform’s capabilities.\nReturns the SCALE encoding of this enum. Always guaranteed …\nSee <code>service::ChainNetwork::gossip_send_block_announce</code>.\nSends a storage proof request to the given peer.\nSubscribes to the networking events that happen on the …\nReturns a base-58 encoded string of this <code>PeerId</code>.\nAddress passed to <code>PlatformRef::connect_stream</code>.\nConnection type passed to …\n<code>Future</code> that resolves once a certain amount of time has …\nSubstream has been opened by the remote.\nA certain point in time. Typically <code>std::time::Instant</code>, but …\nLog level of a log entry.\nA multi-stream connection.\nAddress passed to <code>PlatformRef::connect_multistream</code>.\n<code>Future</code> returned by <code>PlatformRef::connect_multistream</code>.\nEstablished multistream connection information. See …\n<code>Future</code> returned by <code>PlatformRef::next_substream</code>.\nSubstream has been opened locally in response to …\nAccess to a platform’s capabilities.\nObject that dereferences to <code>read_write::ReadWrite</code> and …\nOpaque object representing either a single-stream …\n<code>Future</code> returned by <code>PlatformRef::connect_stream</code>.\nReference to an error that happened on a stream.\n<code>Future</code> returned by <code>PlatformRef::wait_read_write_again</code>.\nDirection in which a substream has been opened. See …\nTCP/IP connection.\nTCP/IP connection with a domain name.\nTCP/IP connection with an IP address.\nTCP/IP connection.\nTCP/IP connection.\nLibp2p-specific WebRTC flavour.\nLibp2p-specific WebRTC flavour.\nLibp2p-specific WebRTC flavour.\nWebSocket connection.\nWebSocket connection with a domain name.\nWebSocket connection with an IP address.\nNon-secure WebSocket connection.\nNon-secure WebSocket connection.\nImplementation of a <code>PlatformRef</code> that wraps around another …\nValue returned when a JSON-RPC client requests the name of …\nValue returned when a JSON-RPC client requests the version …\nStarts a connection attempt to the given address.\nStarts a connection attempt to the given address.\nObject representing the WebRTC connection.\nImplementation of the <code>PlatformRef</code> trait that leverages the …\nThe given buffer must be completely filled with …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSHA256 hash of the TLS certificate used by the local node …\nEmit a log line.\nBuilds a new <code>WithPrefix</code>.\nWaits until a new incoming substream arrives on the …\nReturns an object that represents “now”.\nReturns the time elapsed since the Unix Epoch (i.e. …\nQueues the opening of an additional outbound substream.\nReturns an object that implements …\nCreates a future that becomes ready after at least the …\nCreates a future that becomes ready after the given …\nSpawns a task that runs indefinitely in the background.\nReturns <code>true</code> if <code>PlatformRef::connect_stream</code> or …\nReturns a future that becomes ready when …\nAugments an implementation of <code>AsyncRead</code> and <code>AsyncWrite</code> …\nDNS hostname to connect to.\nDNS hostname to connect to.\nIP address to connect to.\nIP address to connect to.\nTCP port to connect to.\nTCP port to connect to.\nTCP port to connect to.\nTCP port to connect to.\n<code>true</code> for WebSocket secure connections.\n<code>true</code> if the target of the connection is <code>localhost</code>.\n<code>true</code> if the target of the connection is <code>localhost</code>.\n<code>true</code> if the target of the connection is <code>localhost</code>.\n<code>true</code> for WebSocket secure connections.\nIP address to connect to.\nUDP port to connect to.\nSHA-256 hash of the target’s WebRTC certificate.\nMultiaddr contains a multihash whose length doesn’t …\nMultiaddr contains a <code>/certhash</code> components whose multihash …\nMultiaddress contains a domain name that isn’t UTF-8.\nUnknown combination of protocols.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParses a <code>Multiaddr</code> into an <code>Address</code> or <code>MultiStreamAddress</code>.\nImplementation of the <code>PlatformRef</code> trait that leverages the …\nImplementation detail of <code>DefaultPlatform</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new <code>DefaultPlatform</code>.\nError potentially returned by …\nError potentially returned by …\nInvalid LEB128 number.\nReading side of the stream is closed.\nReading side of the stream is closed.\nNumber of bytes decoded is larger than expected.\nSets the writing side of the connection to closed.\nDiscards all the incoming data. Updates …\nNumber of bytes that <code>ReadWrite::incoming_buffer</code> should …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nBuffer of socket data ready to be processed.\nReturns the size of the data available in the incoming …\nExtract a certain number of bytes from the read buffer.\nSame as <code>ReadWrite::incoming_bytes_take_array</code>, but reads a …\nExtract an LEB128-encoded number from the start of the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the connection should be considered dead. …\nTotal number of bytes that have been read from …\nSets <code>ReadWrite::wake_up_after</code> to <code>min(wake_up_after, after)</code>.\nIf <code>Some</code>, the socket must be waken up after the given <code>TNow</code> …\nSets <code>ReadWrite::wake_up_after</code> to the value in …\nList of buffers containing data to the written out. The …\nNumber of additional bytes that are allowed to be pushed …\nAmount of data already queued, both outside and including …\nCopies as much as possible from the content of <code>data</code> to …\nCopies as much as possible from the content of <code>data</code> to …\nAdds the <code>data</code> to <code>ReadWrite::write_buffers</code>, increases …\nSee <code>WithBuffers::read_write_access</code>.\nHolds an implementation of <code>AsyncRead</code> and <code>AsyncWrite</code>, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInitializes a new <code>WithBuffers</code> with the given …\nReturns an object that implements <code>Deref&lt;Target = ReadWrite&gt;</code>…\nWaits until <code>WithBuffers::read_write_access</code> should be …")
// Smoldot
// Copyright (C) 2019-2023  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

use crate::executor::host;

use alloc::{string::String, vec::Vec};
use core::fmt;

/// Configuration for [`run`].
pub struct Config<'a, TParams> {
    /// Virtual machine to be run.
    pub virtual_machine: host::HostVmPrototype,

    /// Name of the function to be called.
    pub function_to_call: &'a str,

    /// Parameter of the call, as an iterator of bytes. The concatenation of bytes forms the
    /// actual input.
    pub parameter: TParams,

    /// Initial state of [`Success::offchain_storage_changes`]. The changes made during this
    /// execution will be pushed over the value in this field.
    pub offchain_storage_changes: hashbrown::HashMap<Vec<u8>, Option<Vec<u8>>, fnv::FnvBuildHasher>,

    /// Maximum log level of the runtime.
    ///
    /// > **Note**: This value is opaque from the point of the view of the client, and the runtime
    /// >           is free to interpret it the way it wants. However, usually values are: `0` for
    /// >           "off", `1` for "error", `2` for "warn", `3` for "info", `4` for "debug",
    /// >           and `5` for "trace".
    pub max_log_level: u32,
}

/// Start running the WebAssembly virtual machine.
pub fn run(
    config: Config<impl Iterator<Item = impl AsRef<[u8]>> + Clone>,
) -> Result<OffchainRuntimeHostVm, (host::StartErr, host::HostVmPrototype)> {
    Ok(Inner {
        vm: config
            .virtual_machine
            .run_vectored(config.function_to_call, config.parameter)?
            .into(),
        logs: String::new(),
        overlay_storage: Default::default(),
        offchain_storage_changes: config.offchain_storage_changes,
        max_log_level: config.max_log_level,
    }
    .run())
}

/// Execution is successful.
#[derive(Debug)]
pub struct Success {
    /// Contains the output value of the runtime, and the virtual machine that was passed at
    /// initialization.
    pub virtual_machine: SuccessVirtualMachine,
    /// List of changes to the off-chain storage.
    pub offchain_storage_changes: hashbrown::HashMap<Vec<u8>, Option<Vec<u8>>, fnv::FnvBuildHasher>,
    /// Concatenation of all the log messages printed by the runtime.
    pub logs: String,
}

/// Function execution has succeeded. Contains the return value of the call.
pub struct SuccessVirtualMachine(host::Finished);

impl SuccessVirtualMachine {
    /// Returns the value the called function has returned.
    pub fn value(&'_ self) -> impl AsRef<[u8]> + '_ {
        self.0.value()
    }

    /// Turns the virtual machine back into a prototype.
    pub fn into_prototype(self) -> host::HostVmPrototype {
        self.0.into_prototype()
    }
}

impl fmt::Debug for SuccessVirtualMachine {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_tuple("SuccessVirtualMachine").finish()
    }
}

/// Error that can happen during the execution.
#[derive(Debug, derive_more::Display)]
#[display(fmt = "{detail}")]
pub struct Error {
    /// Exact error that happened.
    pub detail: ErrorDetail,
    /// Prototype of the virtual machine that was passed through [`Config::virtual_machine`].
    pub prototype: host::HostVmPrototype,
}

/// See [`Error::detail`].
#[derive(Debug, Clone, derive_more::Display)]
pub enum ErrorDetail {
    /// Error while executing the Wasm virtual machine.
    #[display(fmt = "Error while executing Wasm VM: {error}\n{logs:?}")]
    WasmVm {
        /// Error that happened.
        error: host::Error,
        /// Concatenation of all the log messages printed by the runtime.
        logs: String,
    },
    /// Size of the logs generated by the runtime exceeds the limit.
    LogsTooLong,
    ForbiddenHostCall,
    /// The root hash of a child trie stored in the main trie is invalid.
    ChildTrieRootHashInvalidLength,
}

/// Current state of the execution.
#[must_use]
pub enum OffchainRuntimeHostVm {
    /// Execution is over.
    Finished(Result<Success, Error>),
    /// Loading a storage value is required in order to continue.
    StorageGet(StorageGet),
    /// Fetching the key that follows a given one is required in order to continue.
    NextKey(NextKey),
    /// Must load an offchain storage value.
    OffchainStorageGet(OffchainStorageGet),
    /// Need to provide the current timestamp.
    OffchainTimestamp(OffchainTimestamp),
    /// Must return random seed.
    OffchainRandomSeed(OffchainRandomSeed),
    /// Submit a transaction from offchain worker.
    OffchainSubmitTransaction(OffchainSubmitTransaction),
}

impl OffchainRuntimeHostVm {
    /// Cancels execution of the virtual machine and returns back the prototype.
    pub fn into_prototype(self) -> host::HostVmPrototype {
        match self {
            OffchainRuntimeHostVm::Finished(Ok(inner)) => inner.virtual_machine.into_prototype(),
            OffchainRuntimeHostVm::Finished(Err(inner)) => inner.prototype,
            OffchainRuntimeHostVm::StorageGet(inner) => inner.inner.vm.into_prototype(),
            OffchainRuntimeHostVm::NextKey(inner) => inner.inner.vm.into_prototype(),
            OffchainRuntimeHostVm::OffchainStorageGet(inner) => inner.inner.vm.into_prototype(),
            OffchainRuntimeHostVm::OffchainTimestamp(inner) => inner.inner.vm.into_prototype(),
            OffchainRuntimeHostVm::OffchainRandomSeed(inner) => inner.inner.vm.into_prototype(),
            OffchainRuntimeHostVm::OffchainSubmitTransaction(inner) => {
                inner.inner.vm.into_prototype()
            }
        }
    }
}

/// Loading a storage value is required in order to continue.
#[must_use]
pub struct StorageGet {
    inner: Inner,
}

impl StorageGet {
    /// Returns the key whose value must be passed to [`StorageGet::inject_value`].
    pub fn key(&'_ self) -> impl AsRef<[u8]> + '_ {
        match &self.inner.vm {
            host::HostVm::ExternalStorageGet(req) => req.key(),
            // We only create a `StorageGet` if the state is one of the above.
            _ => unreachable!(),
        }
    }

    /// If `Some`, read from the given child trie. If `None`, read from the main trie.
    pub fn child_trie(&'_ self) -> Option<impl AsRef<[u8]> + '_> {
        match &self.inner.vm {
            host::HostVm::ExternalStorageGet(req) => req.child_trie(),
            _ => unreachable!(),
        }
    }

    /// Injects the corresponding storage value.
    pub fn inject_value(mut self, value: Option<impl AsRef<[u8]>>) -> OffchainRuntimeHostVm {
        match self.inner.vm {
            host::HostVm::ExternalStorageGet(req) => {
                self.inner.vm = req.resume_full_value(value.as_ref().map(|k| k.as_ref()));
            }

            // We only create a `StorageGet` if the state is one of the above.
            _ => unreachable!(),
        };

        self.inner.run()
    }
}

/// Fetching the key that follows a given one is required in order to continue.
#[must_use]
pub struct NextKey {
    inner: Inner,
}

impl NextKey {
    /// Returns the key whose next key must be passed back.
    pub fn key(&'_ self) -> impl AsRef<[u8]> + '_ {
        match &self.inner.vm {
            host::HostVm::ExternalStorageNextKey(req) => req.key(),
            _ => unreachable!(),
        }
    }

    /// If `Some`, read from the given child trie. If `None`, read from the main trie.
    pub fn child_trie(&'_ self) -> Option<impl AsRef<[u8]> + '_> {
        match &self.inner.vm {
            host::HostVm::ExternalStorageNextKey(req) => req.child_trie(),
            _ => unreachable!(),
        }
    }

    /// If `true`, then the provided value must the one superior or equal to the requested key.
    /// If `false`, then the provided value must be strictly superior to the requested key.
    pub fn or_equal(&self) -> bool {
        false
    }

    /// If `true`, then the search must include both branch nodes and storage nodes. If `false`,
    /// the search only covers storage nodes.
    pub fn branch_nodes(&self) -> bool {
        false
    }

    /// Returns the prefix the next key must start with. If the next key doesn't start with the
    /// given prefix, then `None` should be provided.
    pub fn prefix(&'_ self) -> impl AsRef<[u8]> + '_ {
        &[][..]
    }

    /// Injects the key.
    ///
    /// # Panic
    ///
    /// Panics if the key passed as parameter isn't strictly superior to the requested key.
    ///
    pub fn inject_key(mut self, key: Option<impl AsRef<[u8]>>) -> OffchainRuntimeHostVm {
        let key = key.as_ref().map(|k| k.as_ref());

        match self.inner.vm {
            host::HostVm::ExternalStorageNextKey(req) => {
                self.inner.vm = req.resume(key.as_ref().map(|v| &v[..]));
            }

            // We only create a `NextKey` if the state is the one above.
            _ => unreachable!(),
        };

        self.inner.run()
    }
}

/// Loading an offchain storage value is required in order to continue.
#[must_use]
pub struct OffchainStorageGet {
    inner: Inner,
}

impl OffchainStorageGet {
    /// Returns the key whose value must be passed to [`OffchainStorageGet::inject_value`].
    pub fn key(&'_ self) -> impl AsRef<[u8]> + '_ {
        match &self.inner.vm {
            host::HostVm::ExternalOffchainStorageGet(req) => req.key(),
            // We only create a `OffchainStorageGet` if the state is one of the above.
            _ => unreachable!(),
        }
    }

    /// Injects the corresponding storage value.
    pub fn inject_value(mut self, value: Option<impl AsRef<[u8]>>) -> OffchainRuntimeHostVm {
        match self.inner.vm {
            host::HostVm::ExternalOffchainStorageGet(req) => {
                self.inner.vm = req.resume(value.as_ref().map(|v| v.as_ref()));
            }
            // We only create a `OffchainStorageGet` if the state is one of the above.
            _ => unreachable!(),
        };

        self.inner.run()
    }
}

/// Loading timestamp is required in order to continue.
#[must_use]
pub struct OffchainTimestamp {
    inner: Inner,
}

impl OffchainTimestamp {
    /// Injects timestamp.
    pub fn inject_timestamp(mut self, value: u64) -> OffchainRuntimeHostVm {
        match self.inner.vm {
            host::HostVm::OffchainTimestamp(req) => {
                self.inner.vm = req.resume(value);
            }
            // We only create a `OffchainTimestamp` if the state is one of the above.
            _ => unreachable!(),
        };

        self.inner.run()
    }
}

/// Loading random seed is required in order to continue.
#[must_use]
pub struct OffchainRandomSeed {
    inner: Inner,
}

impl OffchainRandomSeed {
    /// Injects random seed.
    pub fn inject_random_seed(mut self, value: [u8; 32]) -> OffchainRuntimeHostVm {
        match self.inner.vm {
            host::HostVm::OffchainRandomSeed(req) => {
                self.inner.vm = req.resume(value);
            }
            // We only create a `OffchainRandomSeed` if the state is one of the above.
            _ => unreachable!(),
        };

        self.inner.run()
    }
}

/// Submit transaction is required in order to continue.
#[must_use]
pub struct OffchainSubmitTransaction {
    inner: Inner,
}

impl OffchainSubmitTransaction {
    pub fn transaction(&'_ self) -> impl AsRef<[u8]> + '_ {
        match &self.inner.vm {
            host::HostVm::OffchainSubmitTransaction(req) => req.transaction(),
            // We only create a `OffchainSubmitTransaction` if the state is one of the above.
            _ => unreachable!(),
        }
    }
    /// Injects outcome.
    pub fn inject_outcome(mut self, value: impl AsRef<[u8]>) -> OffchainRuntimeHostVm {
        match self.inner.vm {
            host::HostVm::OffchainSubmitTransaction(req) => {
                let value = value.as_ref();
                self.inner.vm = req.resume((value, value.len()));
            }
            // We only create a `OffchainSubmitTransaction` if the state is one of the above.
            _ => unreachable!(),
        };

        self.inner.run()
    }
}

/// Implementation detail of the execution. Shared by all the variants of [`OffchainRuntimeHostVm`]
/// other than [`OffchainRuntimeHostVm::Finished`].
struct Inner {
    /// Virtual machine running the call.
    vm: host::HostVm,
    /// The changes made during execution.
    pub overlay_storage: hashbrown::HashMap<Vec<u8>, Option<Vec<u8>>, fnv::FnvBuildHasher>,
    /// Pending changes to the off-chain storage that this execution performs.
    offchain_storage_changes: hashbrown::HashMap<Vec<u8>, Option<Vec<u8>>, fnv::FnvBuildHasher>,
    /// Concatenation of all the log messages generated by the runtime.
    logs: String,
    /// Value provided by [`Config::max_log_level`].
    max_log_level: u32,
}

impl Inner {
    /// Continues the execution.
    fn run(mut self) -> OffchainRuntimeHostVm {
        loop {
            match self.vm {
                host::HostVm::ReadyToRun(r) => self.vm = r.run(),

                host::HostVm::Error { error, prototype } => {
                    return OffchainRuntimeHostVm::Finished(Err(Error {
                        detail: ErrorDetail::WasmVm {
                            error,
                            logs: self.logs,
                        },
                        prototype,
                    }));
                }

                host::HostVm::Finished(finished) => {
                    return OffchainRuntimeHostVm::Finished(Ok(Success {
                        virtual_machine: SuccessVirtualMachine(finished),
                        offchain_storage_changes: self.offchain_storage_changes,
                        logs: self.logs,
                    }));
                }

                host::HostVm::ExternalStorageGet(req) => {
                    let key = req.key().as_ref().to_vec();

                    match self.overlay_storage.get(&key) {
                        Some(value) => {
                            self.vm = req.resume_full_value(value.as_ref().map(|v| &v[..]));
                        }
                        None => {
                            self.vm = req.into();
                            return OffchainRuntimeHostVm::StorageGet(StorageGet { inner: self });
                        }
                    }
                }

                host::HostVm::ExternalStorageSet(req) => {
                    let key = req.key().as_ref().to_vec();
                    let value = req.value().map(|v| v.as_ref().to_vec());
                    self.overlay_storage.insert(key, value);
                    self.vm = req.resume()
                }

                host::HostVm::ExternalStorageNextKey(req) => {
                    self.vm = req.into();
                    return OffchainRuntimeHostVm::NextKey(NextKey { inner: self });
                }

                host::HostVm::GetMaxLogLevel(resume) => {
                    self.vm = resume.resume(self.max_log_level);
                }

                host::HostVm::LogEmit(req) => {
                    // We add a hardcoded limit to the logs generated by the runtime in order to
                    // make sure that there is no memory leak. In practice, the runtime should
                    // rarely log more than a few hundred bytes. This limit is hardcoded rather
                    // than configurable because it is not expected to be reachable unless
                    // something is very wrong.
                    struct WriterWithMax<'a>(&'a mut String);
                    impl<'a> fmt::Write for WriterWithMax<'a> {
                        fn write_str(&mut self, s: &str) -> fmt::Result {
                            if self.0.len().saturating_add(s.len()) >= 1024 * 1024 {
                                return Err(fmt::Error);
                            }
                            self.0.push_str(s);
                            Ok(())
                        }
                        fn write_char(&mut self, c: char) -> fmt::Result {
                            if self.0.len().saturating_add(1) >= 1024 * 1024 {
                                return Err(fmt::Error);
                            }
                            self.0.push(c);
                            Ok(())
                        }
                    }
                    match fmt::write(&mut WriterWithMax(&mut self.logs), format_args!("{req}")) {
                        Ok(()) => {}
                        Err(fmt::Error) => {
                            return OffchainRuntimeHostVm::Finished(Err(Error {
                                detail: ErrorDetail::LogsTooLong,
                                prototype: host::HostVm::LogEmit(req).into_prototype(),
                            }));
                        }
                    }
                    self.vm = req.resume();
                }

                host::HostVm::ExternalOffchainStorageGet(req) => {
                    let overlay = self.offchain_storage_changes.get(req.key().as_ref());
                    match overlay {
                        Some(value) => self.vm = req.resume(value.as_ref().map(|v| &v[..])),
                        None => {
                            self.vm = req.into();
                            return OffchainRuntimeHostVm::OffchainStorageGet(OffchainStorageGet {
                                inner: self,
                            });
                        }
                    }
                }

                host::HostVm::ExternalOffchainStorageSet(req) => {
                    let overlay = self.offchain_storage_changes.get(req.key().as_ref());

                    let replace = match (overlay, req.old_value()) {
                        (Some(Some(overlay)), Some(old_value)) => {
                            old_value.as_ref().to_vec().eq(overlay)
                        }
                        _ => true,
                    };

                    if replace {
                        if let Some(value) = req.value() {
                            self.offchain_storage_changes
                                .insert(req.key().as_ref().to_vec(), Some(value.as_ref().to_vec()));
                        } else {
                            self.offchain_storage_changes.remove(req.key().as_ref());
                        }
                    }

                    self.vm = req.resume(replace);
                }

                host::HostVm::OffchainTimestamp(req) => {
                    self.vm = req.into();
                    return OffchainRuntimeHostVm::OffchainTimestamp(OffchainTimestamp {
                        inner: self,
                    });
                }

                host::HostVm::OffchainRandomSeed(req) => {
                    self.vm = req.into();
                    return OffchainRuntimeHostVm::OffchainRandomSeed(OffchainRandomSeed {
                        inner: self,
                    });
                }

                host::HostVm::OffchainSubmitTransaction(req) => {
                    self.vm = req.into();
                    return OffchainRuntimeHostVm::OffchainSubmitTransaction(
                        OffchainSubmitTransaction { inner: self },
                    );
                }

                other => {
                    return OffchainRuntimeHostVm::Finished(Err(Error {
                        detail: ErrorDetail::ForbiddenHostCall,
                        prototype: other.into_prototype(),
                    }))
                }
            }
        }
    }
}

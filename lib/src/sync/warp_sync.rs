// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

//! Warp syncing.
//!
//! Warp syncing makes it possible to very quickly reach the currently finalized block of a chain.
//! No attempt is made at verifying blocks. The algorithm assumes that the currently finalized
//! block is valid, as the chain is likely bricked if this is not the case.
//!
//! # Long range attack vulnerability
//!
//! Warp syncing is particularly vulnerable to what is called long range attacks.
//!
//! The authorities allowed to finalize blocks can generate multiple proofs of finality for
//! multiple different blocks of the same height. In other words, they can finalize more than one
//! chain at a time.
//!
//! Finalizing multiple chains at the same time is called an equivocation. Client implementations
//! detect equivocations and report them to the runtime. While this is out of scope of the client,
//! the runtime then typically provides a mechanism that punishes the validators that have
//! equivocated.
//! However, this defense mechanism is flawed in case when a long time passes between the
//! multiple finality proofs generated by the same validators. Clients cannot hold an unlimited
//! amount of information in memory, so they might not detect the equivocation, and even if it is
//! detected, the punishment might not be enforceable because validators have moved all their
//! funds.
//!
//! In other words, it is possible for two thirds of the validators that were active at a certain
//! past block N to collude and decide to finalize a different block N, even when N has been
//! finalized for the first time several weeks or months in the past. When a client then warp
//! syncs, it can be tricked to consider this alternative block N as the finalized one.
//!
//! There is no fool-proof defense against this attack. However, consider the extremely high
//! investment and high risk for the malicious validators, and the difficulty of pulling off this
//! attack, it is extremely unlikely to happen in reality.
//! The aforementioned punishment system is the only defense against this attack, and in order to
//! be effective, the starting point of the warp syncing shouldn't be too far in the past. How
//! far exactly depends on the logic of the runtime of the chain.
//!
//! # Overview
//!
//! The warp syncing algorithm works only if the chain uses Grandpa for its finality.
//! It consists in the following steps:
//!
//! - Downloading a warp sync proof from a source. This proof contains a list of *fragments*. Each
//! fragment represents a change in the list of Grandpa authorities, and a list of signatures of
//! the previous authorities that certify that this change is correct.
//! - Verifying the fragments. Each fragment that is successfully verified progresses towards
//! the head of the chain. Even if one fragment is invalid, all the previously-verified
//! fragments can still be kept, and the warp syncing can resume from there.
//! - Downloading from a source the runtime code of the final block of the proof.
//! - Performing some runtime calls in order to obtain the current consensus-related parameters
//! of the chain. This might require obtaining some storage items, in which case they must also
//! be downloaded from a source.
//!
//! At the end of the syncing, a [`ValidChainInformation`] corresponding to the head of the chain
//! is yielded.
//!
//! # Usage
//!
//! Use the [`start_warp_sync()`] function to start a Grandpa warp syncing state machine.
//!
//! At any given moment, this state machine holds a list of *sources* that it might use to
//! download the warp sync proof or the runtime code. Sources must be added and removed by the API
//! user by calling one of the various `add_source` and `remove_source` functions.
//!
//! Sources are identified through a [`SourceId`]. Each source has an opaque so-called "user data"
//! of type `TSrc` associated to it. The content of this "user data" is at the discretion of the
//! API user.
//!
//! Similarly, at any given moment, this state machine holds a list of requests that concern these
//! sources. Use [`InProgressWarpSync::desired_requests`] to determine which requests will be
//! useful to the progress of the warp syncing, then use [`InProgressWarpSync::add_request`] to
//! update the state machine with a newly-started request.
//!
//! Use [`InProgressWarpSync::process_one`] in order to run verifications of the payloads that have
//! previously been downloaded.
//!

use crate::{
    chain::chain_information::{
        self, ChainInformationConsensusRef, ChainInformationFinality, ChainInformationFinalityRef,
        ValidChainInformation, ValidChainInformationRef,
    },
    executor::{
        self,
        host::{self, HostVmPrototype},
        vm::ExecHint,
    },
    header::{self, Header},
    trie::{self, proof_decode},
};

use alloc::{
    borrow::{Cow, ToOwned as _},
    vec,
    vec::Vec,
};
use core::{iter, mem, ops};

pub use trie::Nibble;
pub use verifier::{Error as FragmentError, WarpSyncFragment};

mod verifier;

/// Problem encountered during a call to [`start_warp_sync()`].
#[derive(Debug, derive_more::Display)]
pub enum Error {
    /// The chain doesn't include any storage item at `:code`.
    #[display(fmt = "The chain doesn't include any storage item at `:code`")]
    MissingCode,
    /// The storage item at `:heappages` is in an incorrect format.
    #[display(fmt = "Invalid heap pages value: {_0}")]
    InvalidHeapPages(executor::InvalidHeapPagesError),
    /// Error building the runtime of the chain.
    #[display(fmt = "Error building the runtime: {_0}")]
    RuntimeBuild(executor::host::NewErr),
    /// Error building the chain information.
    #[display(fmt = "Error building the chain information: {_0}")]
    ChainInformationBuild(chain_information::build::Error),
    /// Failed to verify Merkle proof.
    // TODO: this is a non-fatal error contrary to all the other errors in this enum
    InvalidMerkleProof(proof_decode::Error),
    /// Merkle proof is missing the necessary entries.
    // TODO: this is a non-fatal error contrary to all the other errors in this enum
    MerkleProofEntriesMissing,
    /// Warp sync requires fetching the key that follows another one. This isn't implemented in
    /// smoldot.
    NextKeyUnimplemented,
}

/// The configuration for [`start_warp_sync()`].
#[derive(Debug)]
pub struct Config {
    /// The chain information of the starting point of the warp syncing.
    pub start_chain_information: ValidChainInformation,

    /// Number of bytes used when encoding/decoding the block number. Influences how various data
    /// structures should be parsed.
    pub block_number_bytes: usize,

    /// The initial capacity of the list of sources.
    pub sources_capacity: usize,

    /// The initial capacity of the list of requests.
    pub requests_capacity: usize,

    /// Known valid Merkle value and storage value combination for the `:code` key.
    ///
    /// If provided, the warp syncing algorithm will first fetch the Merkle value of `:code`, and
    /// if it matches the Merkle value provided in the hint, use the storage value in the hint
    /// instead of downloading it. If the hint doesn't match, an extra round-trip will be needed,
    /// but if the hint matches it saves a big download.
    pub code_trie_node_hint: Option<ConfigCodeTrieNodeHint>,
}

/// See [`Config::code_trie_node_hint`].
#[derive(Debug)]
pub struct ConfigCodeTrieNodeHint {
    /// Potential Merkle value of the `:code` key.
    pub merkle_value: Vec<u8>,

    /// Storage value corresponding to [`ConfigCodeTrieNodeHint::merkle_value`].
    pub storage_value: Vec<u8>,

    /// Closest ancestor of the `:code` key except for `:code` itself.
    pub closest_ancestor_excluding: Vec<Nibble>,
}

/// Initializes the warp sync state machine.
///
/// On error, returns the [`ValidChainInformation`] that was provided in the configuration.
pub fn start_warp_sync<TSrc, TRq>(
    config: Config,
) -> Result<InProgressWarpSync<TSrc, TRq>, (ValidChainInformation, WarpSyncInitError)> {
    match config.start_chain_information.as_ref().finality {
        ChainInformationFinalityRef::Grandpa { .. } => {}
        _ => {
            return Err((
                config.start_chain_information,
                WarpSyncInitError::NotGrandpa,
            ))
        }
    }

    match config.start_chain_information.as_ref().consensus {
        ChainInformationConsensusRef::Babe { .. } | ChainInformationConsensusRef::Aura { .. } => {}
        ChainInformationConsensusRef::Unknown => {
            return Err((
                config.start_chain_information,
                WarpSyncInitError::UnknownConsensus,
            ))
        }
    }

    Ok(InProgressWarpSync {
        phase: Phase::DownloadFragments,
        warped_header: config
            .start_chain_information
            .as_ref()
            .finalized_block_header
            .into(),
        warped_finality: config.start_chain_information.as_ref().finality.into(),
        start_chain_information: config.start_chain_information,
        code_trie_node_hint: config.code_trie_node_hint,
        block_number_bytes: config.block_number_bytes,
        sources: slab::Slab::with_capacity(config.sources_capacity),
        in_progress_requests: slab::Slab::with_capacity(config.requests_capacity),
    })
}

/// Error potentially returned by [`start_warp_sync()`].
#[derive(Debug, derive_more::Display, Clone)]
pub enum WarpSyncInitError {
    /// Chain doesn't use the Grandpa finality algorithm.
    NotGrandpa,
    /// Chain uses an unrecognized consensus mechanism.
    UnknownConsensus,
}

/// Identifier for a source in the [`WarpSync`].
//
// Implementation note: this represents the index within the `Slab` used for the list of sources.
#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub struct SourceId(usize);

impl SourceId {
    /// Returns the smallest possible [`SourceId`]. It is always inferior or equal to any other.
    pub fn min_value() -> Self {
        SourceId(usize::min_value())
    }

    pub fn checked_add(&self, n: u8) -> Option<Self> {
        Some(SourceId(self.0.checked_add(usize::from(n))?))
    }
}

/// The result of a successful warp sync.
pub struct Success<TSrc, TRq> {
    /// The synced chain information.
    pub chain_information: ValidChainInformation,

    /// The runtime constructed in `VirtualMachineParamsGet`. Corresponds to the runtime of the
    /// finalized block of [`Success::chain_information`].
    pub finalized_runtime: HostVmPrototype,

    /// Storage value at the `:code` key of the finalized block.
    pub finalized_storage_code: Option<Vec<u8>>,

    /// Storage value at the `:heappages` key of the finalized block.
    pub finalized_storage_heap_pages: Option<Vec<u8>>,

    /// Merkle value of the `:code` trie node of the finalized block.
    pub finalized_storage_code_merkle_value: Option<Vec<u8>>,

    /// Closest ancestor of the `:code` trie node of the finalized block excluding `:code` itself.
    pub finalized_storage_code_closest_ancestor_excluding: Option<Vec<Nibble>>,

    /// The list of sources that were added to the state machine, with their finalized block
    /// height and user data.
    /// The list is ordered by [`SourceId`].
    // TODO: use a struct?
    pub sources_ordered: Vec<(SourceId, u64, TSrc)>,

    /// The list of requests that were added to the state machine.
    pub in_progress_requests: Vec<(SourceId, RequestId, TRq, RequestDetail)>,
}

/// The warp sync state machine.
#[derive(derive_more::From)]
pub enum WarpSync<TSrc, TRq> {
    /// Warp syncing is over.
    Finished(Success<TSrc, TRq>),
    /// Warp syncing is in progress,
    InProgress(InProgressWarpSync<TSrc, TRq>),
}

impl<TSrc, TRq> ops::Index<SourceId> for InProgressWarpSync<TSrc, TRq> {
    type Output = TSrc;

    #[track_caller]
    fn index(&self, source_id: SourceId) -> &TSrc {
        debug_assert!(self.sources.contains(source_id.0));
        &self.sources[source_id.0].user_data
    }
}

impl<TSrc, TRq> ops::IndexMut<SourceId> for InProgressWarpSync<TSrc, TRq> {
    #[track_caller]
    fn index_mut(&mut self, source_id: SourceId) -> &mut TSrc {
        debug_assert!(self.sources.contains(source_id.0));
        &mut self.sources[source_id.0].user_data
    }
}

/// Warp syncing process now obtaining the chain information.
pub struct InProgressWarpSync<TSrc, TRq> {
    /// See [`Phase`].
    phase: Phase,
    /// Finalized block of the chain we warp synced to.
    warped_header: Header,
    /// Information about the finality of the chain at the point where we warp synced to.
    warped_finality: ChainInformationFinality,
    /// See [`Config::code_trie_node_hint`].
    code_trie_node_hint: Option<ConfigCodeTrieNodeHint>,
    /// Starting point of the warp syncing, as provided to [`start_warp_sync`].
    start_chain_information: ValidChainInformation,
    /// Number of bytes used to encode the block number in headers.
    block_number_bytes: usize,
    /// List of requests that have been added using [`InProgressWarpSync::add_source`].
    sources: slab::Slab<Source<TSrc>>,
    /// List of requests that have been added using [`InProgressWarpSync::add_request`].
    in_progress_requests: slab::Slab<(SourceId, TRq, RequestDetail)>,
}

enum Phase {
    /// Downloading warp sync fragments.
    DownloadFragments,
    /// Warp sync fragments have been downloaded. Now to verify them.
    PendingVerify {
        /// Source the fragments have been obtained from
        downloaded_source: SourceId,
        /// `true` if the source has indicated that there is no more fragment afterwards, in other
        /// words that the last fragment corresponds to the current finalized block of the chain.
        final_set_of_fragments: bool,
        /// Contains the downloaded fragments.
        /// Always `Some`, but wrapped within an `Option` in order to permit extracting
        /// temporarily.
        verifier: Option<verifier::Verifier>,
    },
    /// All warp sync fragments have been verified, and we are now downloading the runtime of the
    /// finalized block of the chain.
    RuntimeDownload {
        /// Source we downloaded the last fragments from. Assuming that the source isn't malicious,
        /// it is guaranteed to have access to the storage of the finalized block.
        warp_sync_source_id: SourceId,
        /// `true` if it is known that [`InProgressWarpSync::code_trie_node_hint`] doesn't match
        /// the storage of the header we warp synced to.
        hint_doesnt_match: bool,
        /// Merkle proof containing the runtime information, or `None` if it was not downloaded yet.
        downloaded_runtime: Option<Vec<u8>>,
    },
    /// All warp sync fragments have been verified, we have downloaded the runtime of the finalized
    /// block, and we are now downloading and computing the information of the chain.
    ChainInformationDownload {
        /// Source we downloaded the last fragments from. Assuming that the source isn't malicious,
        /// it is guaranteed to have access to the storage of the finalized block.
        warp_sync_source_id: SourceId,
        /// Merkle proof containing the runtime information.
        /// Always `Some`, but wrapped within an `Option` in order to allow extraction.
        downloaded_runtime: Option<DownloadedRuntime>,
        /// State machine that builds the chain information.
        /// This state machine is built ahead of time but isn't driven until everything has been
        /// downloaded.
        /// Always `Some`, but wrapped within an `Option` in order to allow extraction.
        chain_info_builder: Option<chain_information::build::InProgress>,
        /// For each call required by the chain information builder, whether it has been
        /// downloaded yet.
        calls: hashbrown::HashMap<
            chain_information::build::RuntimeCall,
            Option<Vec<u8>>,
            fnv::FnvBuildHasher,
        >,
    },
}

struct DownloadedRuntime {
    /// Storage item at the `:code` key. `None` if there is no entry at that key.
    storage_code: Option<Vec<u8>>,
    /// Storage item at the `:heappages` key. `None` if there is no entry at that key.
    storage_heap_pages: Option<Vec<u8>>,
    /// Merkle value of the `:code` trie node. `None` if there is no entry at that key.
    code_merkle_value: Option<Vec<u8>>,
    /// Closest ancestor of the `:code` key except for `:code` itself.
    closest_ancestor_excluding: Option<Vec<Nibble>>,
}

/// See [`InProgressWarpSync::status`].
#[derive(Debug)]
pub enum Status<'a, TSrc> {
    /// Warp syncing algorithm is downloading Grandpa warp sync fragments containing a finality
    /// proof.
    Fragments {
        /// Source from which the fragments are currently being downloaded, if any.
        source: Option<(SourceId, &'a TSrc)>,
        /// Hash of the highest block that is proven to be finalized.
        ///
        /// This isn't necessarily the same block as returned by
        /// [`InProgressWarpSync::as_chain_information`], as this function first has to download
        /// extra information compared to just the finalized block.
        finalized_block_hash: [u8; 32],
        /// Height of the block indicated by [`Status::ChainInformation::finalized_block_hash`].
        finalized_block_number: u64,
    },
    /// Warp syncing algorithm has reached the head of the finalized chain and is downloading and
    /// building the chain information.
    ChainInformation {
        /// Source from which the chain information is being downloaded.
        source: (SourceId, &'a TSrc),
        /// Hash of the highest block that is proven to be finalized.
        ///
        /// This isn't necessarily the same block as returned by
        /// [`InProgressWarpSync::as_chain_information`], as this function first has to download
        /// extra information compared to just the finalized block.
        finalized_block_hash: [u8; 32],
        /// Height of the block indicated by [`Status::ChainInformation::finalized_block_hash`].
        finalized_block_number: u64,
    },
}

impl<TSrc, TRq> InProgressWarpSync<TSrc, TRq> {
    /// Returns the value that was initially passed in [`Config::block_number_bytes`].
    pub fn block_number_bytes(&self) -> usize {
        self.block_number_bytes
    }

    /// Returns the chain information that is considered verified.
    pub fn as_chain_information(&self) -> ValidChainInformationRef {
        // Note: after verifying a warp sync fragment, we are certain that the header targeted by
        // this fragment is indeed part of the chain. However, this is not enough in order to
        // produce a full chain information struct. Such struct can only be produced after the
        // entire warp syncing has succeeded. If if it still in progress, all we can return is
        // the starting point.
        (&self.start_chain_information).into()
    }

    /// Returns the current status of the warp syncing.
    pub fn status(&self) -> Status<TSrc> {
        match self.phase {
            Phase::DownloadFragments => {
                let finalized_block_hash = self.warped_header.hash(self.block_number_bytes);

                let source_id =
                    self.in_progress_requests
                        .iter()
                        .find_map(|(_, (source_id, _, rq))| match rq {
                            RequestDetail::WarpSyncRequest { block_hash }
                                if *block_hash == finalized_block_hash =>
                            {
                                Some(*source_id)
                            }
                            _ => None,
                        });

                Status::Fragments {
                    source: source_id.map(|id| (id, &self.sources[id.0].user_data)),
                    finalized_block_hash,
                    finalized_block_number: self.warped_header.number,
                }
            }
            Phase::PendingVerify {
                downloaded_source, ..
            } => Status::Fragments {
                source: Some((
                    downloaded_source,
                    &self.sources[downloaded_source.0].user_data,
                )),
                finalized_block_hash: self.warped_header.hash(self.block_number_bytes),
                finalized_block_number: self.warped_header.number,
            },
            Phase::RuntimeDownload {
                warp_sync_source_id,
                ..
            }
            | Phase::ChainInformationDownload {
                warp_sync_source_id,
                ..
            } => Status::ChainInformation {
                source: (
                    warp_sync_source_id,
                    &self.sources[warp_sync_source_id.0].user_data,
                ),
                finalized_block_hash: self.warped_header.hash(self.block_number_bytes),
                finalized_block_number: self.warped_header.number,
            },
        }
    }

    /// Returns a list of all known sources stored in the state machine.
    pub fn sources(&'_ self) -> impl Iterator<Item = SourceId> + '_ {
        self.sources.iter().map(|(id, _)| SourceId(id))
    }

    /// Add a source to the list of sources.
    ///
    /// The source has a finalized block height of 0, which should later be updated using
    /// [`InProgressWarpSync::set_source_finality_state`].
    pub fn add_source(&mut self, user_data: TSrc) -> SourceId {
        SourceId(self.sources.insert(Source {
            user_data,
            already_tried: false,
            finalized_block_height: 0,
        }))
    }

    /// Removes a source from the list of sources. In addition to the user data associated to this
    /// source, also returns a list of requests that were in progress concerning this source. These
    /// requests are now considered obsolete.
    ///
    /// # Panic
    ///
    /// Panics if the [`SourceId`] is invalid.
    ///
    pub fn remove_source(
        &'_ mut self,
        to_remove: SourceId,
    ) -> (TSrc, impl Iterator<Item = (RequestId, TRq)> + '_) {
        debug_assert!(self.sources.contains(to_remove.0));
        let removed = self.sources.remove(to_remove.0).user_data;

        if let Phase::RuntimeDownload {
            warp_sync_source_id,
            ..
        }
        | Phase::ChainInformationDownload {
            warp_sync_source_id,
            ..
        } = &self.phase
        {
            if to_remove == *warp_sync_source_id {
                self.phase = Phase::DownloadFragments;
            }
        } else if let Phase::PendingVerify {
            downloaded_source, ..
        } = &mut self.phase
        {
            // We make sure to not leave invalid source IDs in the state of `self`.
            // While it is a waste of bandwidth to completely remove a proof that has already
            // been downloaded if the source disconnects, it is in practice not something that is
            // supposed to happen.
            if *downloaded_source == to_remove {
                self.phase = Phase::DownloadFragments;
            }
        }

        let obsolete_requests_indices = self
            .in_progress_requests
            .iter()
            .filter_map(|(id, (src, _, _))| if *src == to_remove { Some(id) } else { None })
            .collect::<Vec<_>>();
        let mut obsolete_requests = Vec::with_capacity(obsolete_requests_indices.len());
        for index in obsolete_requests_indices {
            let (_, user_data, _) = self.in_progress_requests.remove(index);
            obsolete_requests.push((RequestId(index), user_data));
        }

        (removed, obsolete_requests.into_iter())
    }

    /// Sets the finalized block height of the given source.
    ///
    /// # Panic
    ///
    /// Panics if `source_id` is invalid.
    ///
    pub fn set_source_finality_state(&mut self, source_id: SourceId, finalized_block_height: u64) {
        self.sources[source_id.0].finalized_block_height = finalized_block_height;
    }

    /// Returns a list of requests that should be started in order to drive the warp syncing
    /// process to completion.
    ///
    /// Once a request that matches a desired request is added through
    /// [`InProgressWarpSync::add_request`], it is no longer returned by this function.
    pub fn desired_requests(
        &'_ self,
    ) -> impl Iterator<Item = (SourceId, &'_ TSrc, DesiredRequest)> + '_ {
        // If we are in the fragments download phase, return a fragments download request.
        let warp_sync_request = if let Phase::DownloadFragments = &self.phase {
            // TODO: it feels like a hack to try again sources that have failed in the past; also, this means that the already_tried mechanism only works once
            let all_sources_already_tried = self.sources.iter().all(|(_, s)| s.already_tried);

            let start_block_hash = self.warped_header.hash(self.block_number_bytes);

            // TODO: O(n)
            if !self.in_progress_requests.iter().any(|(_, (_, _, rq))| {
                matches!(rq,
                    RequestDetail::WarpSyncRequest { block_hash }
                        if *block_hash == start_block_hash)
            }) {
                // Combine the request with every single available source.
                either::Left(self.sources.iter().filter_map(move |(src_id, src)| {
                    // TODO: also filter by source finalized block? so that we don't request from sources below us
                    if all_sources_already_tried || !src.already_tried {
                        Some((
                            SourceId(src_id),
                            &src.user_data,
                            DesiredRequest::WarpSyncRequest {
                                block_hash: start_block_hash,
                            },
                        ))
                    } else {
                        None
                    }
                }))
            } else {
                either::Right(iter::empty())
            }
        } else {
            either::Right(iter::empty())
        };

        // If we are in the appropriate phase, and we are not currently downloading the runtime,
        // return a runtime download request.
        let runtime_parameters_get = if let Phase::RuntimeDownload {
            warp_sync_source_id,
            hint_doesnt_match,
            downloaded_runtime: None,
            ..
        } = &self.phase
        {
            let code_key_to_request = if let (false, Some(hint)) =
                (*hint_doesnt_match, self.code_trie_node_hint.as_ref())
            {
                Cow::Owned(
                    trie::nibbles_to_bytes_truncate(
                        hint.closest_ancestor_excluding.iter().copied(),
                    )
                    .collect::<Vec<_>>(),
                )
            } else {
                Cow::Borrowed(&b":code"[..])
            };

            // TODO: O(n)
            if !self.in_progress_requests.iter().any(|(_, rq)| {
                rq.0 == *warp_sync_source_id
                    && matches!(rq.2,
                        RequestDetail::StorageGetMerkleProof {
                            block_hash: ref b,
                            ref keys,
                        } if *b == self.warped_header.hash(self.block_number_bytes)
                            && keys.iter().any(|k| *k == *code_key_to_request)
                            && keys.iter().any(|k| k == b":heappages"))
            }) {
                Some((
                    *warp_sync_source_id,
                    &self.sources[warp_sync_source_id.0].user_data,
                    DesiredRequest::StorageGetMerkleProof {
                        block_hash: self.warped_header.hash(self.block_number_bytes),
                        state_trie_root: self.warped_header.state_root,
                        keys: vec![code_key_to_request.to_vec(), b":heappages".to_vec()],
                    },
                ))
            } else {
                None
            }
        } else {
            None
        };

        // If we are in the appropriate phase, return the list of runtime calls indicated by the
        // chain information builder state machine.
        let call_proofs = if let Phase::ChainInformationDownload {
            warp_sync_source_id,
            calls,
            ..
        } = &self.phase
        {
            either::Left(
                // TODO: O(n)
                calls
                    .iter()
                    .filter(|(_, v)| v.is_none())
                    .filter_map(|(call, _)| {
                        if self.in_progress_requests.iter().any(
                            |(_, (_, _, detail))| match detail {
                                RequestDetail::RuntimeCallMerkleProof {
                                    function_name,
                                    parameter_vectored,
                                    ..
                                } => {
                                    function_name == call.function_name()
                                        && parameters_equal(
                                            parameter_vectored,
                                            call.parameter_vectored(),
                                        )
                                }
                                _ => false,
                            },
                        ) {
                            return None;
                        }

                        Some((
                            *warp_sync_source_id,
                            &self.sources[warp_sync_source_id.0].user_data,
                            DesiredRequest::RuntimeCallMerkleProof {
                                block_hash: self.warped_header.hash(self.block_number_bytes),
                                function_name: call.function_name().into(),
                                parameter_vectored: Cow::Owned(call.parameter_vectored_vec()),
                            },
                        ))
                    }),
            )
        } else {
            either::Right(iter::empty())
        };

        // Chain all these demanded requests together.
        warp_sync_request
            .chain(runtime_parameters_get.into_iter())
            .chain(call_proofs)
    }

    /// Inserts a new request in the data structure.
    ///
    /// > **Note**: The request doesn't necessarily have to match a request returned by
    /// >           [`InProgressWarpSync::desired_requests`].
    ///
    /// # Panic
    ///
    /// Panics if the [`SourceId`] is out of range.
    ///
    pub fn add_request(
        &mut self,
        source_id: SourceId,
        user_data: TRq,
        detail: RequestDetail,
    ) -> RequestId {
        assert!(self.sources.contains(source_id.0));
        RequestId(
            self.in_progress_requests
                .insert((source_id, user_data, detail)),
        )
    }

    /// Removes the given request from the state machine. Returns the user data that was associated
    /// to it.
    ///
    /// # Panic
    ///
    /// Panics if the [`RequestId`] is invalid.
    ///
    pub fn fail_request(&mut self, id: RequestId) -> TRq {
        match (self.in_progress_requests.remove(id.0), &mut self.phase) {
            ((source_id, user_data, RequestDetail::WarpSyncRequest { .. }), _) => {
                // TODO: check that block hash matches starting point? ^
                self.sources[source_id.0].already_tried = true;
                user_data
            }
            (
                (
                    source_id,
                    user_data,
                    RequestDetail::RuntimeCallMerkleProof { .. }
                    | RequestDetail::StorageGetMerkleProof { .. },
                ),
                Phase::RuntimeDownload {
                    warp_sync_source_id,
                    ..
                },
            ) if source_id == *warp_sync_source_id => {
                // If the source has failed a request, we jump back to downloading fragments
                // in order to try a different source.
                self.sources[source_id.0].already_tried = true;
                self.phase = Phase::DownloadFragments;
                user_data
            }
            (
                (
                    _,
                    user_data,
                    RequestDetail::RuntimeCallMerkleProof { .. }
                    | RequestDetail::StorageGetMerkleProof { .. },
                ),
                _,
            ) => user_data,
        }
    }

    /// Injects a successful Merkle proof and removes the given request from the state machine.
    /// Returns the user data that was associated to it.
    ///
    /// # Panic
    ///
    /// Panics if the [`RequestId`] is invalid.
    /// Panics if the [`RequestId`] doesn't correspond to a storage get request.
    ///
    pub fn storage_get_success(&mut self, id: RequestId, merkle_proof: Vec<u8>) -> TRq {
        // Remove the request from the list, obtaining its user data.
        // If the request corresponds to the runtime parameters we're looking for, the function
        // continues below, otherwise we return early.
        let user_data = match (self.in_progress_requests.remove(id.0), &self.phase) {
            (
                (
                    _,
                    user_data,
                    RequestDetail::StorageGetMerkleProof {
                        ref block_hash,
                        ref keys,
                    },
                ),
                Phase::RuntimeDownload { .. },
            ) if *block_hash == self.warped_header.hash(self.block_number_bytes)
                // TODO: doesn't check for `:cod` ,but in practice this doesn't really matter anyway
                && keys.iter().any(|k| k == b":heappages") =>
            {
                user_data
            }
            ((_, user_data, RequestDetail::StorageGetMerkleProof { .. }), _) => return user_data,
            (
                (
                    _,
                    _,
                    RequestDetail::RuntimeCallMerkleProof { .. }
                    | RequestDetail::WarpSyncRequest { .. },
                ),
                _,
            ) => panic!(),
        };

        if let Phase::RuntimeDownload {
            downloaded_runtime, ..
        } = &mut self.phase
        {
            *downloaded_runtime = Some(merkle_proof);
        } else {
            // This is checked at the beginning of this function.
            unreachable!()
        }

        user_data
    }

    /// Injects a successful response and removes the given request from the state machine. Returns
    /// the user data that was associated to it.
    ///
    /// # Panic
    ///
    /// Panics if the [`RequestId`] is invalid.
    /// Panics if the [`RequestId`] doesn't correspond to a runtime Merkle call proof request.
    ///
    pub fn runtime_call_merkle_proof_success(
        &mut self,
        request_id: RequestId,
        response: Vec<u8>,
    ) -> TRq {
        match (
            self.in_progress_requests.remove(request_id.0),
            &mut self.phase,
        ) {
            (
                (
                    _,
                    user_data,
                    RequestDetail::RuntimeCallMerkleProof {
                        block_hash,
                        function_name,
                        parameter_vectored,
                    },
                ),
                Phase::ChainInformationDownload { ref mut calls, .. },
            ) if block_hash == self.warped_header.hash(self.block_number_bytes) => {
                for (call, value) in calls.iter_mut() {
                    if function_name == call.function_name()
                        && parameters_equal(&parameter_vectored, call.parameter_vectored())
                    {
                        *value = Some(response);
                        break;
                    }
                }

                user_data
            }

            // Uninteresting request.
            ((_, user_data, RequestDetail::RuntimeCallMerkleProof { .. }), _) => user_data,

            // Wrong request type.
            (
                (_, _, RequestDetail::StorageGetMerkleProof { .. })
                | (_, _, RequestDetail::WarpSyncRequest { .. }),
                _,
            ) => panic!(),
        }
    }

    /// Injects a successful response and removes the given request from the state machine. Returns
    /// the user data that was associated to it.
    ///
    /// # Panic
    ///
    /// Panics if the [`RequestId`] is invalid.
    /// Panics if the [`RequestId`] doesn't correspond to a warp sync request.
    ///
    // TODO: more zero cost API w.r.t. the fragments
    pub fn warp_sync_request_success(
        &mut self,
        request_id: RequestId,
        fragments: Vec<WarpSyncFragment>,
        final_set_of_fragments: bool,
    ) -> TRq {
        match (
            self.in_progress_requests.remove(request_id.0),
            &mut self.phase,
        ) {
            (
                (rq_source_id, user_data, RequestDetail::WarpSyncRequest { block_hash }),
                Phase::DownloadFragments,
            ) => {
                let desired_block_hash = self.warped_header.hash(self.block_number_bytes);

                // Uninteresting request. We downloaded fragments from the wrong starting point.
                if desired_block_hash != block_hash {
                    return user_data;
                }

                // TODO: why this?
                self.sources[rq_source_id.0].already_tried = true;

                let verifier = verifier::Verifier::new(
                    (&self.warped_finality).into(),
                    self.block_number_bytes,
                    fragments,
                    final_set_of_fragments,
                );

                self.phase = Phase::PendingVerify {
                    final_set_of_fragments,
                    downloaded_source: rq_source_id,
                    verifier: Some(verifier),
                };

                user_data
            }
            ((_, user_data, RequestDetail::WarpSyncRequest { .. }), _) => {
                // Uninteresting download. We simply ignore the response.
                user_data
            }
            ((_, _, _), _) => panic!(),
        }
    }

    /// Start processing one CPU operation.
    ///
    /// This function takes ownership of `self` and yields it back after the operation is finished.
    pub fn process_one(self) -> ProcessOne<TSrc, TRq> {
        if let Phase::ChainInformationDownload { calls, .. } = &self.phase {
            // If we've downloaded everything that was needed, switch to "build chain information"
            // mode.
            if calls.values().all(Option::is_some) {
                return ProcessOne::BuildChainInformation(BuildChainInformation { inner: self });
            }
        }

        if let Phase::RuntimeDownload {
            downloaded_runtime: Some(_),
            ..
        } = &self.phase
        {
            return ProcessOne::BuildRuntime(BuildRuntime { inner: self });
        }

        if let Phase::PendingVerify { .. } = &self.phase {
            return ProcessOne::VerifyWarpSyncFragment(VerifyWarpSyncFragment { inner: self });
        }

        ProcessOne::Idle(self)
    }
}

#[derive(Debug, Copy, Clone)]
struct Source<TSrc> {
    user_data: TSrc,
    /// `true` if this source has been in a past warp sync request and we should try a different
    /// source.
    already_tried: bool,
    finalized_block_height: u64,
}

/// Information about a request that the warp sync state machine would like to start.
///
/// See [`InProgressWarpSync::desired_requests`].
#[derive(Debug, Clone)]
pub enum DesiredRequest {
    /// A warp sync request should be start.
    WarpSyncRequest {
        /// Starting point of the warp syncing. The first fragment of the response should be the
        /// of the epoch that the starting point is in.
        block_hash: [u8; 32],
    },
    /// A storage request of the runtime code and heap pages should be started.
    StorageGetMerkleProof {
        /// Hash of the block to request the parameters against.
        block_hash: [u8; 32],
        /// State trie root hash found in the header of the block.
        state_trie_root: [u8; 32],
        /// Keys whose values are requested.
        // TODO: consider Cow<'static, [u8]> instead
        keys: Vec<Vec<u8>>,
    },
    /// A call proof should be started.
    RuntimeCallMerkleProof {
        /// Hash of the header of the block the call should be made against.
        block_hash: [u8; 32],
        /// Name of the function of the call proof.
        function_name: Cow<'static, str>,
        /// Parameters of the call.
        parameter_vectored: Cow<'static, [u8]>,
    },
}

/// Information about a request to add to the state machine.
///
/// See [`InProgressWarpSync::add_request`].
#[derive(Debug, Clone)]
pub enum RequestDetail {
    /// See [`DesiredRequest::WarpSyncRequest`].
    WarpSyncRequest {
        /// See [`DesiredRequest::WarpSyncRequest::block_hash`].
        block_hash: [u8; 32],
    },
    /// See [`DesiredRequest::StorageGetMerkleProof`].
    StorageGetMerkleProof {
        /// See [`DesiredRequest::StorageGetMerkleProof::block_hash`].
        block_hash: [u8; 32],
        /// See [`DesiredRequest::StorageGetMerkleProof::keys`].
        keys: Vec<Vec<u8>>,
    },
    /// See [`DesiredRequest::RuntimeCallMerkleProof`].
    RuntimeCallMerkleProof {
        /// See [`DesiredRequest::RuntimeCallMerkleProof::block_hash`].
        block_hash: [u8; 32],
        /// See [`DesiredRequest::RuntimeCallMerkleProof::function_name`].
        function_name: Cow<'static, str>,
        /// See [`DesiredRequest::RuntimeCallMerkleProof::parameter_vectored`].
        parameter_vectored: Cow<'static, [u8]>,
    },
}

/// Identifier for a request in the warp sync state machine.
#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub struct RequestId(usize);

/// Return value of [`InProgressWarpSync::process_one`].
pub enum ProcessOne<TSrc, TRq> {
    /// Nothing to verify at the moment. The state machine is yielded back.
    Idle(InProgressWarpSync<TSrc, TRq>),
    /// Ready to verify a warp sync fragment.
    VerifyWarpSyncFragment(VerifyWarpSyncFragment<TSrc, TRq>),
    /// Ready to build the runtime of the chain..
    BuildRuntime(BuildRuntime<TSrc, TRq>),
    /// Ready to verify the parameters of the chain against the finalized block.
    BuildChainInformation(BuildChainInformation<TSrc, TRq>),
}

/// Ready to verify a warp sync fragment.
pub struct VerifyWarpSyncFragment<TSrc, TRq> {
    inner: InProgressWarpSync<TSrc, TRq>,
}

impl<TSrc, TRq> VerifyWarpSyncFragment<TSrc, TRq> {
    /// Returns the source that has sent the fragments that we are about to verify, and its user
    /// data.
    pub fn proof_sender(&self) -> (SourceId, &TSrc) {
        if let Phase::PendingVerify {
            downloaded_source, ..
        } = &self.inner.phase
        {
            (
                *downloaded_source,
                &self.inner.sources[downloaded_source.0].user_data,
            )
        } else {
            unreachable!()
        }
    }

    /// Verify one warp sync fragment.
    ///
    /// Must be passed a randomly-generated value that is used by the verification process. Note
    /// that the verification is still deterministic.
    // TODO: does this API make sense? refactor or explain what this error is
    pub fn verify(
        mut self,
        randomness_seed: [u8; 32],
    ) -> (InProgressWarpSync<TSrc, TRq>, Option<FragmentError>) {
        if let Phase::PendingVerify {
            verifier,
            final_set_of_fragments,
            downloaded_source,
            ..
        } = &mut self.inner.phase
        {
            match verifier.take().unwrap().next(randomness_seed) {
                Ok(verifier::Next::NotFinished(next_verifier)) => {
                    *verifier = Some(next_verifier);
                }
                Ok(verifier::Next::EmptyProof) => {
                    self.inner.warped_header = self
                        .inner
                        .start_chain_information
                        .as_ref()
                        .finalized_block_header
                        .into();
                    self.inner.warped_finality =
                        self.inner.start_chain_information.as_ref().finality.into();
                    self.inner.phase = Phase::RuntimeDownload {
                        warp_sync_source_id: *downloaded_source,
                        downloaded_runtime: None,
                        hint_doesnt_match: false,
                    };
                }
                Ok(verifier::Next::Success {
                    scale_encoded_header,
                    chain_information_finality,
                }) => {
                    // As the verification of the fragment has succeeded, we are sure that the header
                    // is valid and can decode it.
                    self.inner.warped_header =
                        header::decode(&scale_encoded_header, self.inner.block_number_bytes)
                            .unwrap()
                            .into();
                    self.inner.warped_finality = chain_information_finality;

                    if *final_set_of_fragments {
                        self.inner.phase = Phase::RuntimeDownload {
                            warp_sync_source_id: *downloaded_source,
                            downloaded_runtime: None,
                            hint_doesnt_match: false,
                        };
                    } else {
                        self.inner.phase = Phase::DownloadFragments;
                    }
                }
                Err(error) => {
                    self.inner.phase = Phase::DownloadFragments;
                    return (self.inner, Some(error));
                }
            }

            (self.inner, None)
        } else {
            unreachable!()
        }
    }
}

/// Ready to build the runtime of the finalized chain.
pub struct BuildRuntime<TSrc, TRq> {
    inner: InProgressWarpSync<TSrc, TRq>,
}

impl<TSrc, TRq> BuildRuntime<TSrc, TRq> {
    /// Build the runtime of the chain.
    ///
    /// This function might return a [`WarpSync::Finished`], indicating the end of the warp sync.
    ///
    /// Must be passed parameters used for the construction of the runtime: a hint as to whether
    /// the runtime is trusted and/or will be executed again, and whether unresolved function
    /// imports are allowed.
    // TODO: refactor this error or explain what it is
    pub fn build(
        mut self,
        exec_hint: ExecHint,
        allow_unresolved_imports: bool,
    ) -> (WarpSync<TSrc, TRq>, Option<Error>) {
        if let Phase::RuntimeDownload {
            downloaded_runtime,
            warp_sync_source_id,
            hint_doesnt_match,
            ..
        } = &mut self.inner.phase
        {
            let downloaded_runtime = downloaded_runtime.take().unwrap();
            let decoded_downloaded_runtime =
                match proof_decode::decode_and_verify_proof(proof_decode::Config {
                    proof: &downloaded_runtime[..],
                }) {
                    Ok(p) => p,
                    Err(err) => {
                        self.inner.phase = Phase::DownloadFragments;
                        return (
                            WarpSync::InProgress(self.inner),
                            Some(Error::InvalidMerkleProof(err)),
                        );
                    }
                };

            let (
                finalized_storage_code_merkle_value,
                finalized_storage_code_closest_ancestor_excluding,
            ) = {
                let code_nibbles =
                    trie::bytes_to_nibbles(b":code".iter().copied()).collect::<Vec<_>>();
                match decoded_downloaded_runtime.closest_ancestor_in_proof(
                    &self.inner.warped_header.state_root,
                    &code_nibbles[..code_nibbles.len() - 1],
                ) {
                    Ok(Some(closest_ancestor_key)) => {
                        let next_nibble = code_nibbles[closest_ancestor_key.len()];
                        let merkle_value = decoded_downloaded_runtime
                            .trie_node_info(
                                &self.inner.warped_header.state_root,
                                closest_ancestor_key,
                            )
                            .unwrap()
                            .children
                            .child(next_nibble)
                            .merkle_value();

                        match merkle_value {
                            Some(mv) => (mv.to_owned(), closest_ancestor_key.to_vec()),
                            None => {
                                self.inner.phase = Phase::DownloadFragments;
                                return (
                                    WarpSync::InProgress(self.inner),
                                    Some(Error::MissingCode),
                                );
                            }
                        }
                    }
                    Ok(None) => {
                        self.inner.phase = Phase::DownloadFragments;
                        return (WarpSync::InProgress(self.inner), Some(Error::MissingCode));
                    }
                    Err(proof_decode::IncompleteProofError { .. }) => {
                        self.inner.phase = Phase::DownloadFragments;
                        return (
                            WarpSync::InProgress(self.inner),
                            Some(Error::MerkleProofEntriesMissing),
                        );
                    }
                }
            };

            let finalized_storage_code = if let (false, Some(hint)) =
                (*hint_doesnt_match, self.inner.code_trie_node_hint.as_ref())
            {
                if hint.merkle_value == finalized_storage_code_merkle_value {
                    &hint.storage_value
                } else {
                    *hint_doesnt_match = true;
                    return (WarpSync::InProgress(self.inner), None);
                }
            } else {
                match decoded_downloaded_runtime
                    .storage_value(&self.inner.warped_header.state_root, b":code")
                {
                    Ok(Some((code, _))) => code,
                    Ok(None) => {
                        self.inner.phase = Phase::DownloadFragments;
                        return (WarpSync::InProgress(self.inner), Some(Error::MissingCode));
                    }
                    Err(proof_decode::IncompleteProofError { .. }) => {
                        return (
                            WarpSync::InProgress(self.inner),
                            Some(Error::MerkleProofEntriesMissing),
                        );
                    }
                }
            };

            let finalized_storage_heappages = match decoded_downloaded_runtime
                .storage_value(&self.inner.warped_header.state_root, b":heappages")
            {
                Ok(val) => val.map(|(v, _)| v),
                Err(proof_decode::IncompleteProofError { .. }) => {
                    return (
                        WarpSync::InProgress(self.inner),
                        Some(Error::MerkleProofEntriesMissing),
                    );
                }
            };

            let decoded_heap_pages =
                match executor::storage_heap_pages_to_value(finalized_storage_heappages) {
                    Ok(hp) => hp,
                    Err(err) => {
                        self.inner.phase = Phase::DownloadFragments;
                        return (
                            WarpSync::InProgress(self.inner),
                            Some(Error::InvalidHeapPages(err)),
                        );
                    }
                };

            let runtime = match HostVmPrototype::new(host::Config {
                module: &finalized_storage_code,
                heap_pages: decoded_heap_pages,
                exec_hint,
                allow_unresolved_imports,
            }) {
                Ok(runtime) => runtime,
                Err(err) => {
                    self.inner.phase = Phase::DownloadFragments;
                    return (
                        WarpSync::InProgress(self.inner),
                        Some(Error::RuntimeBuild(err)),
                    );
                }
            };

            let chain_info_builder = chain_information::build::ChainInformationBuild::new(
                chain_information::build::Config {
                    finalized_block_header: if self.inner.warped_header.number == 0 {
                        chain_information::build::ConfigFinalizedBlockHeader::Genesis {
                            state_trie_root_hash: self.inner.warped_header.state_root,
                        }
                    } else {
                        chain_information::build::ConfigFinalizedBlockHeader::NonGenesis {
                            scale_encoded_header: self
                                .inner
                                .warped_header
                                .scale_encoding_vec(self.inner.block_number_bytes),
                            known_finality: Some((&self.inner.warped_finality).clone()),
                        }
                    },
                    block_number_bytes: self.inner.block_number_bytes,
                    runtime,
                },
            );

            let (calls, chain_info_builder) = match chain_info_builder {
                chain_information::build::ChainInformationBuild::Finished {
                    result: Ok(chain_information),
                    virtual_machine,
                } => {
                    return (
                        WarpSync::Finished(Success {
                            chain_information,
                            finalized_runtime: virtual_machine,
                            finalized_storage_code: Some(finalized_storage_code.to_owned()),
                            finalized_storage_heap_pages: finalized_storage_heappages
                                .map(|v| v.to_vec()),
                            finalized_storage_code_merkle_value: Some(
                                finalized_storage_code_merkle_value,
                            ),
                            finalized_storage_code_closest_ancestor_excluding: Some(
                                finalized_storage_code_closest_ancestor_excluding,
                            ),
                            sources_ordered: mem::take(&mut self.inner.sources)
                                .into_iter()
                                .map(|(id, source)| {
                                    (
                                        SourceId(id),
                                        source.finalized_block_height,
                                        source.user_data,
                                    )
                                })
                                .collect(),
                            in_progress_requests: mem::take(&mut self.inner.in_progress_requests)
                                .into_iter()
                                .map(|(id, (src_id, user_data, detail))| {
                                    (src_id, RequestId(id), user_data, detail)
                                })
                                .collect(),
                        }),
                        None,
                    );
                }
                chain_information::build::ChainInformationBuild::Finished {
                    result: Err(err),
                    ..
                } => {
                    self.inner.phase = Phase::DownloadFragments;
                    return (
                        WarpSync::InProgress(self.inner),
                        Some(Error::ChainInformationBuild(err)),
                    );
                }
                chain_information::build::ChainInformationBuild::InProgress(in_progress) => {
                    let calls = in_progress
                        .remaining_calls()
                        .map(|call| (call, None))
                        .collect();
                    (calls, in_progress)
                }
            };

            self.inner.phase = Phase::ChainInformationDownload {
                warp_sync_source_id: *warp_sync_source_id,
                downloaded_runtime: Some(DownloadedRuntime {
                    storage_code: Some(finalized_storage_code.to_vec()),
                    storage_heap_pages: finalized_storage_heappages.map(|v| v.to_vec()),
                    code_merkle_value: Some(finalized_storage_code_merkle_value),
                    closest_ancestor_excluding: Some(
                        finalized_storage_code_closest_ancestor_excluding,
                    ),
                }),
                chain_info_builder: Some(chain_info_builder),
                calls,
            };

            (WarpSync::InProgress(self.inner), None)
        } else {
            unreachable!()
        }
    }
}

/// Ready to verify the parameters of the chain against the finalized block.
pub struct BuildChainInformation<TSrc, TRq> {
    inner: InProgressWarpSync<TSrc, TRq>,
}

impl<TSrc, TRq> BuildChainInformation<TSrc, TRq> {
    /// Build the information about the chain.
    ///
    /// This function might return a [`WarpSync::Finished`], indicating the end of the warp sync.
    // TODO: refactor this error or explain what it is
    pub fn build(mut self) -> (WarpSync<TSrc, TRq>, Option<Error>) {
        if let Phase::ChainInformationDownload {
            chain_info_builder,
            downloaded_runtime,
            calls,
            ..
        } = &mut self.inner.phase
        {
            debug_assert!(calls.values().all(Option::is_some));

            // Decode all the Merkle proofs that have been received.
            let calls = {
                let mut decoded_proofs = hashbrown::HashMap::with_capacity_and_hasher(
                    calls.len(),
                    fnv::FnvBuildHasher::default(),
                );

                for (call, proof) in calls {
                    let proof = proof.take().unwrap();
                    let decoded_proof =
                        match proof_decode::decode_and_verify_proof(proof_decode::Config {
                            proof: proof.into_iter(),
                        }) {
                            Ok(d) => d,
                            Err(err) => {
                                self.inner.phase = Phase::DownloadFragments;
                                return (
                                    WarpSync::InProgress(self.inner),
                                    Some(Error::InvalidMerkleProof(err)),
                                );
                            }
                        };
                    decoded_proofs.insert(*call, decoded_proof);
                }

                decoded_proofs
            };

            let mut chain_info_builder = chain_info_builder.take().unwrap();

            loop {
                match chain_info_builder {
                    chain_information::build::InProgress::StorageGet(get) => {
                        // TODO: child tries not supported
                        let proof = calls.get(&get.call_in_progress()).unwrap();
                        let value = match proof
                            .storage_value(&self.inner.warped_header.state_root, get.key().as_ref())
                        {
                            Ok(v) => v,
                            Err(proof_decode::IncompleteProofError { .. }) => {
                                self.inner.phase = Phase::DownloadFragments;
                                return (
                                    WarpSync::InProgress(self.inner),
                                    Some(Error::MerkleProofEntriesMissing),
                                );
                            }
                        };

                        match get.inject_value(value.map(|(val, ver)| (iter::once(val), ver))) {
                            chain_information::build::ChainInformationBuild::Finished {
                                result: Ok(chain_information),
                                virtual_machine,
                            } => {
                                let downloaded_runtime = downloaded_runtime.take().unwrap();

                                return (
                                    WarpSync::Finished(Success {
                                        chain_information,
                                        finalized_runtime: virtual_machine,
                                        finalized_storage_code: downloaded_runtime.storage_code,
                                        finalized_storage_heap_pages: downloaded_runtime
                                            .storage_heap_pages,
                                        finalized_storage_code_merkle_value: downloaded_runtime
                                            .code_merkle_value,
                                        finalized_storage_code_closest_ancestor_excluding:
                                            downloaded_runtime.closest_ancestor_excluding,
                                        sources_ordered: mem::take(&mut self.inner.sources)
                                            .into_iter()
                                            .map(|(id, source)| {
                                                (
                                                    SourceId(id),
                                                    source.finalized_block_height,
                                                    source.user_data,
                                                )
                                            })
                                            .collect(),
                                        in_progress_requests: mem::take(
                                            &mut self.inner.in_progress_requests,
                                        )
                                        .into_iter()
                                        .map(|(id, (src_id, user_data, detail))| {
                                            (src_id, RequestId(id), user_data, detail)
                                        })
                                        .collect(),
                                    }),
                                    None,
                                );
                            }
                            chain_information::build::ChainInformationBuild::Finished {
                                result: Err(err),
                                ..
                            } => {
                                self.inner.phase = Phase::DownloadFragments;
                                return (
                                    WarpSync::InProgress(self.inner),
                                    Some(Error::ChainInformationBuild(err)),
                                );
                            }
                            chain_information::build::ChainInformationBuild::InProgress(
                                in_progress,
                            ) => {
                                chain_info_builder = in_progress;
                            }
                        }
                    }
                    chain_information::build::InProgress::NextKey(_)
                    | chain_information::build::InProgress::ClosestDescendantMerkleValue(_) => {
                        // TODO: implement
                        self.inner.phase = Phase::DownloadFragments;
                        return (
                            WarpSync::InProgress(self.inner),
                            Some(Error::NextKeyUnimplemented),
                        );
                    }
                }
            }
        } else {
            unreachable!()
        }
    }
}

/// Returns `true` if `a` and `b` are equal.
fn parameters_equal(mut a: &[u8], b: impl Iterator<Item = impl AsRef<[u8]>>) -> bool {
    for slice in b {
        let slice = slice.as_ref();

        if a.len() < slice.len() {
            return false;
        }

        if &a[..slice.len()] != slice {
            return false;
        }

        a = &a[slice.len()..];
    }

    true
}
